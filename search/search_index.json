{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. The equations governing projectile motion involve both linear and quadratic relationships, making them accessible yet deeply insightful. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket. Task 1. Theoretical Foundation Derive the governing equations of motion from fundamental principles. Solve the basic differential equation to establish the general form of the motion. Highlight how variations in initial conditions lead to a family of solutions. 2. Analysis of the Range Investigate how the horizontal range depends on the angle of projection. Discuss how changes in other parameters, such as initial velocity and gravitational acceleration, influence the relationship. 3. Practical Applications Reflect on how this model can be adapted to describe various real-world situations, such as projectiles launched on uneven terrain or in the presence of air resistance. 4. Implementation Develop a computational tool or algorithm to simulate projectile motion. Visualize the range as a function of the angle of projection for different sets of initial conditions. Governing Equations The equations for projectile motion under the influence of gravity (neglecting air resistance) are: [ x = v_0 \\cos(\\theta) t ] [ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 ] The time of flight is given by: \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] The range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation shows that the maximum range is achieved at \\( \\theta = 45^\\circ \\) . Python Implementation import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, g=9.81): angles = np.linspace(0, 90, num=100) ranges = (v0**2 * np.sin(np.radians(2 * angles))) / g plt.figure(figsize=(8, 6)) plt.plot(angles, ranges, label=f'Initial Velocity = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Angle of Projection') plt.legend() plt.grid() plt.show() # Example usage projectile_range(v0=20) Results and Observations The range follows a symmetric pattern, peaking at \\(45^\\circ\\) . Higher initial velocity increases the maximum range. Changing gravity (e.g., different planets) alters the range behavior. Limitations and Further Considerations Air resistance is neglected in this model. Uneven terrain is not accounted for. Real-world effects like wind and spin could be included in a more advanced model. Conclusion This study of projectile motion highlights the elegance of physics and the practical implications of mathematical models. By extending this analysis to include drag or varying gravitational fields, we can better understand complex real-world scenarios, from sports to aerospace engineering.","title":"Problem 1"},{"location":"1Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. The equations governing projectile motion involve both linear and quadratic relationships, making them accessible yet deeply insightful. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket.","title":"Motivation"},{"location":"1Physics/1%20Mechanics/Problem_1/#task","text":"","title":"Task"},{"location":"1Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Derive the governing equations of motion from fundamental principles. Solve the basic differential equation to establish the general form of the motion. Highlight how variations in initial conditions lead to a family of solutions.","title":"1. Theoretical Foundation"},{"location":"1Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"Investigate how the horizontal range depends on the angle of projection. Discuss how changes in other parameters, such as initial velocity and gravitational acceleration, influence the relationship.","title":"2. Analysis of the Range"},{"location":"1Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Reflect on how this model can be adapted to describe various real-world situations, such as projectiles launched on uneven terrain or in the presence of air resistance.","title":"3. Practical Applications"},{"location":"1Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Develop a computational tool or algorithm to simulate projectile motion. Visualize the range as a function of the angle of projection for different sets of initial conditions.","title":"4. Implementation"},{"location":"1Physics/1%20Mechanics/Problem_1/#governing-equations","text":"The equations for projectile motion under the influence of gravity (neglecting air resistance) are: [ x = v_0 \\cos(\\theta) t ] [ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 ] The time of flight is given by: \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] The range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation shows that the maximum range is achieved at \\( \\theta = 45^\\circ \\) .","title":"Governing Equations"},{"location":"1Physics/1%20Mechanics/Problem_1/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, g=9.81): angles = np.linspace(0, 90, num=100) ranges = (v0**2 * np.sin(np.radians(2 * angles))) / g plt.figure(figsize=(8, 6)) plt.plot(angles, ranges, label=f'Initial Velocity = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Angle of Projection') plt.legend() plt.grid() plt.show() # Example usage projectile_range(v0=20)","title":"Python Implementation"},{"location":"1Physics/1%20Mechanics/Problem_1/#results-and-observations","text":"The range follows a symmetric pattern, peaking at \\(45^\\circ\\) . Higher initial velocity increases the maximum range. Changing gravity (e.g., different planets) alters the range behavior.","title":"Results and Observations"},{"location":"1Physics/1%20Mechanics/Problem_1/#limitations-and-further-considerations","text":"Air resistance is neglected in this model. Uneven terrain is not accounted for. Real-world effects like wind and spin could be included in a more advanced model.","title":"Limitations and Further Considerations"},{"location":"1Physics/1%20Mechanics/Problem_1/#conclusion","text":"This study of projectile motion highlights the elegance of physics and the practical implications of mathematical models. By extending this analysis to include drag or varying gravitational fields, we can better understand complex real-world scenarios, from sports to aerospace engineering.","title":"Conclusion"},{"location":"1Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping, restoring forces, and external driving forces. By introducing both damping and external periodic forcing, the system demonstrates a transition from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena serve as a foundation for understanding complex real-world systems, such as driven oscillators, climate systems, and mechanical structures under periodic stress. Adding forcing introduces new parameters, such as the amplitude and frequency of the external force, which significantly affect the pendulum's behavior. By systematically varying these parameters, a diverse class of solutions can be observed, including synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors not only highlight fundamental physics principles but also provide insights into engineering applications such as energy harvesting, vibration isolation, and mechanical resonance. Task 1. Theoretical Foundation Start with the differential equation governing the motion of a forced damped pendulum: [ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) ] Derive the approximate solutions for small-angle oscillations. Explore resonance conditions and their implications for the system's energy. 2. Analysis of Dynamics Investigate how the damping coefficient, driving amplitude, and driving frequency influence the motion of the pendulum. Examine the transition between regular and chaotic motion and their physical interpretations. 3. Practical Applications Discuss real-world scenarios where the forced damped pendulum model applies, such as in energy harvesting devices, suspension bridges, and oscillating circuits. 4. Implementation Create a computational model to simulate the motion of a forced damped pendulum. Visualize the behavior under various damping, driving force, and initial conditions. Plot phase diagrams and Poincar\u00e9 sections to illustrate transitions to chaos. Governing Equations and Approximations For small angles ( \\( \\theta \\approx \\sin\\theta \\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] The steady-state solution can be found using methods like the method of undetermined coefficients or Fourier analysis. Python Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def forced_damped_pendulum(t, y, beta, omega0, A, omega): theta, omega_dot = y return [omega_dot, -beta * omega_dot - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] # Parameters beta = 0.5 # Damping coefficient omega0 = 1.5 # Natural frequency A = 1.2 # Forcing amplitude omega = 2.0 # Driving frequency y0 = [0.2, 0] # Initial conditions (angle, angular velocity) tspan = (0, 50) t_eval = np.linspace(*tspan, 1000) sol = solve_ivp(forced_damped_pendulum, tspan, y0, t_eval=t_eval, args=(beta, omega0, A, omega)) # Plot results plt.figure(figsize=(8, 6)) plt.plot(sol.t, sol.y[0], label='Theta (angle)') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() Results and Observations The motion depends critically on the damping and forcing parameters. Resonance occurs when \\( \\omega \\approx \\omega_0 \\) , leading to large oscillations. Chaos emerges for certain parameter ranges, leading to unpredictable behavior. Advanced Analysis Phase Portraits : Visualize trajectories in phase space. Poincar\u00e9 Sections : Analyze periodicity and chaos. Bifurcation Diagrams : Examine how the system's stability changes with varying parameters. Limitations and Further Considerations Nonlinear damping and external perturbations can be incorporated for realism. Higher-order numerical methods may improve accuracy in chaotic regimes. Real-world applications require considering material properties and external noise. Conclusion The forced damped pendulum serves as a gateway to understanding nonlinear dynamics, chaos, and resonance. By extending this study with computational simulations and advanced mathematical tools, deeper insights into real-world oscillatory systems can be achieved.","title":"Problem 2"},{"location":"1Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping, restoring forces, and external driving forces. By introducing both damping and external periodic forcing, the system demonstrates a transition from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena serve as a foundation for understanding complex real-world systems, such as driven oscillators, climate systems, and mechanical structures under periodic stress. Adding forcing introduces new parameters, such as the amplitude and frequency of the external force, which significantly affect the pendulum's behavior. By systematically varying these parameters, a diverse class of solutions can be observed, including synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors not only highlight fundamental physics principles but also provide insights into engineering applications such as energy harvesting, vibration isolation, and mechanical resonance.","title":"Motivation"},{"location":"1Physics/1%20Mechanics/Problem_2/#task","text":"","title":"Task"},{"location":"1Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"Start with the differential equation governing the motion of a forced damped pendulum: [ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) ] Derive the approximate solutions for small-angle oscillations. Explore resonance conditions and their implications for the system's energy.","title":"1. Theoretical Foundation"},{"location":"1Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Investigate how the damping coefficient, driving amplitude, and driving frequency influence the motion of the pendulum. Examine the transition between regular and chaotic motion and their physical interpretations.","title":"2. Analysis of Dynamics"},{"location":"1Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Discuss real-world scenarios where the forced damped pendulum model applies, such as in energy harvesting devices, suspension bridges, and oscillating circuits.","title":"3. Practical Applications"},{"location":"1Physics/1%20Mechanics/Problem_2/#4-implementation","text":"Create a computational model to simulate the motion of a forced damped pendulum. Visualize the behavior under various damping, driving force, and initial conditions. Plot phase diagrams and Poincar\u00e9 sections to illustrate transitions to chaos.","title":"4. Implementation"},{"location":"1Physics/1%20Mechanics/Problem_2/#governing-equations-and-approximations","text":"For small angles ( \\( \\theta \\approx \\sin\\theta \\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] The steady-state solution can be found using methods like the method of undetermined coefficients or Fourier analysis.","title":"Governing Equations and Approximations"},{"location":"1Physics/1%20Mechanics/Problem_2/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def forced_damped_pendulum(t, y, beta, omega0, A, omega): theta, omega_dot = y return [omega_dot, -beta * omega_dot - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] # Parameters beta = 0.5 # Damping coefficient omega0 = 1.5 # Natural frequency A = 1.2 # Forcing amplitude omega = 2.0 # Driving frequency y0 = [0.2, 0] # Initial conditions (angle, angular velocity) tspan = (0, 50) t_eval = np.linspace(*tspan, 1000) sol = solve_ivp(forced_damped_pendulum, tspan, y0, t_eval=t_eval, args=(beta, omega0, A, omega)) # Plot results plt.figure(figsize=(8, 6)) plt.plot(sol.t, sol.y[0], label='Theta (angle)') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show()","title":"Python Implementation"},{"location":"1Physics/1%20Mechanics/Problem_2/#results-and-observations","text":"The motion depends critically on the damping and forcing parameters. Resonance occurs when \\( \\omega \\approx \\omega_0 \\) , leading to large oscillations. Chaos emerges for certain parameter ranges, leading to unpredictable behavior.","title":"Results and Observations"},{"location":"1Physics/1%20Mechanics/Problem_2/#advanced-analysis","text":"Phase Portraits : Visualize trajectories in phase space. Poincar\u00e9 Sections : Analyze periodicity and chaos. Bifurcation Diagrams : Examine how the system's stability changes with varying parameters.","title":"Advanced Analysis"},{"location":"1Physics/1%20Mechanics/Problem_2/#limitations-and-further-considerations","text":"Nonlinear damping and external perturbations can be incorporated for realism. Higher-order numerical methods may improve accuracy in chaotic regimes. Real-world applications require considering material properties and external noise.","title":"Limitations and Further Considerations"},{"location":"1Physics/1%20Mechanics/Problem_2/#conclusion","text":"The forced damped pendulum serves as a gateway to understanding nonlinear dynamics, chaos, and resonance. By extending this study with computational simulations and advanced mathematical tools, deeper insights into real-world oscillatory systems can be achieved.","title":"Conclusion"},{"location":"1Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law, is a cornerstone of celestial mechanics. This simple yet profound relationship allows for the determination of planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. By analyzing this relationship, one can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems. Task 1. Theoretical Foundation Start with Newton's Law of Gravitation and centripetal force: [ F = \\frac{G M m}{r^2} ] [ F = m \\frac{v^2}{r} ] Equating the two forces for circular orbits and expressing velocity in terms of the orbital period \\(T\\) : [ v = \\frac{2 \\pi r}{T} ] [ \\frac{G M m}{r^2} = m \\frac{(2 \\pi r / T)^2}{r} ] Simplifying gives Kepler\u2019s Third Law: [ T^2 = \\frac{4 \\pi^2 r^3}{G M} ] 2. Implications in Astronomy This relationship allows astronomers to determine planetary masses and distances without direct measurements. It explains why outer planets have longer orbital periods. Used in exoplanet detection and understanding binary star systems. 3. Real-World Examples Earth-Moon System : Applying the law to determine the Moon\u2019s distance. Solar System : Predicting planetary orbits using known masses. Satellite Orbits : Verifying geostationary orbit conditions. 4. Computational Implementation Simulating circular orbits using Newton\u2019s equations. Verifying Kepler\u2019s Third Law numerically. Python Implementation import numpy as np import matplotlib.pyplot as plt def kepler_law(r, M, G=6.67430e-11): return np.sqrt((4 * np.pi**2 * r**3) / (G * M)) # Example: Earth orbiting the Sun M_sun = 1.989e30 # Mass of the Sun in kg r_values = np.linspace(1e10, 1e12, 100) # Orbital radii in meters T_values = kepler_law(r_values, M_sun) plt.figure(figsize=(8, 6)) plt.plot(r_values, T_values**2, label='T^2 vs. r^3') plt.xlabel('Orbital Radius (m)') plt.ylabel('Orbital Period Squared (s^2)') plt.title(\"Kepler's Third Law: T^2 vs. r^3\") plt.legend() plt.grid() plt.show() Results and Observations The graph confirms the linearity between \\(T^2\\) and \\(r^3\\) . Increasing mass \\(M\\) decreases orbital periods for a given radius. Satellites closer to Earth have shorter periods than distant ones. Extension to Elliptical Orbits Kepler\u2019s Third Law holds for elliptical orbits by considering the semi-major axis \\(a\\) instead of \\(r\\) . Used in analyzing asteroid belts and multi-star systems. Conclusion Kepler\u2019s Third Law is fundamental in celestial mechanics, bridging theoretical physics with astronomical observations. By leveraging computational models, we can extend these principles to predict and analyze a variety of orbital phenomena, from planetary motion to artificial satellite deployment.","title":"Problem 1"},{"location":"1Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law, is a cornerstone of celestial mechanics. This simple yet profound relationship allows for the determination of planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. By analyzing this relationship, one can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems.","title":"Motivation"},{"location":"1Physics/2%20Gravity/Problem_1/#task","text":"","title":"Task"},{"location":"1Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","text":"Start with Newton's Law of Gravitation and centripetal force: [ F = \\frac{G M m}{r^2} ] [ F = m \\frac{v^2}{r} ] Equating the two forces for circular orbits and expressing velocity in terms of the orbital period \\(T\\) : [ v = \\frac{2 \\pi r}{T} ] [ \\frac{G M m}{r^2} = m \\frac{(2 \\pi r / T)^2}{r} ] Simplifying gives Kepler\u2019s Third Law: [ T^2 = \\frac{4 \\pi^2 r^3}{G M} ]","title":"1. Theoretical Foundation"},{"location":"1Physics/2%20Gravity/Problem_1/#2-implications-in-astronomy","text":"This relationship allows astronomers to determine planetary masses and distances without direct measurements. It explains why outer planets have longer orbital periods. Used in exoplanet detection and understanding binary star systems.","title":"2. Implications in Astronomy"},{"location":"1Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"Earth-Moon System : Applying the law to determine the Moon\u2019s distance. Solar System : Predicting planetary orbits using known masses. Satellite Orbits : Verifying geostationary orbit conditions.","title":"3. Real-World Examples"},{"location":"1Physics/2%20Gravity/Problem_1/#4-computational-implementation","text":"Simulating circular orbits using Newton\u2019s equations. Verifying Kepler\u2019s Third Law numerically.","title":"4. Computational Implementation"},{"location":"1Physics/2%20Gravity/Problem_1/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt def kepler_law(r, M, G=6.67430e-11): return np.sqrt((4 * np.pi**2 * r**3) / (G * M)) # Example: Earth orbiting the Sun M_sun = 1.989e30 # Mass of the Sun in kg r_values = np.linspace(1e10, 1e12, 100) # Orbital radii in meters T_values = kepler_law(r_values, M_sun) plt.figure(figsize=(8, 6)) plt.plot(r_values, T_values**2, label='T^2 vs. r^3') plt.xlabel('Orbital Radius (m)') plt.ylabel('Orbital Period Squared (s^2)') plt.title(\"Kepler's Third Law: T^2 vs. r^3\") plt.legend() plt.grid() plt.show()","title":"Python Implementation"},{"location":"1Physics/2%20Gravity/Problem_1/#results-and-observations","text":"The graph confirms the linearity between \\(T^2\\) and \\(r^3\\) . Increasing mass \\(M\\) decreases orbital periods for a given radius. Satellites closer to Earth have shorter periods than distant ones.","title":"Results and Observations"},{"location":"1Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"Kepler\u2019s Third Law holds for elliptical orbits by considering the semi-major axis \\(a\\) instead of \\(r\\) . Used in analyzing asteroid belts and multi-star systems.","title":"Extension to Elliptical Orbits"},{"location":"1Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler\u2019s Third Law is fundamental in celestial mechanics, bridging theoretical physics with astronomical observations. By leveraging computational models, we can extend these principles to predict and analyze a variety of orbital phenomena, from planetary motion to artificial satellite deployment.","title":"Conclusion"},{"location":"1Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Task 1. Definition of Cosmic Velocities First Cosmic Velocity (Orbital Velocity) : The minimum velocity required to maintain a stable circular orbit around a celestial body. [ v_1 = \\sqrt{\\frac{GM}{r}} ] Second Cosmic Velocity (Escape Velocity) : The minimum velocity needed to escape a celestial body's gravitational field without further propulsion. [ v_2 = \\sqrt{\\frac{2GM}{r}} = \\sqrt{2} v_1 ] Third Cosmic Velocity (Interstellar Escape Velocity) : The velocity required to escape the gravitational pull of a star system. [ v 3 = \\sqrt{\\frac{2G M {sun}}{r_{orbit}}} ] (For a planet escaping the Solar System) 2. Mathematical Analysis and Influencing Parameters The gravitational constant \\( G = 6.67430 \\times 10^{-11} \\) \\(m^3 kg^{-1} s^{-2}\\) . The mass \\( M \\) of the celestial body significantly affects escape velocity. The radius \\( r \\) of the celestial body determines the strength of gravity at its surface. 3. Real-World Applications Launching Satellites : Achieving the first cosmic velocity allows satellites to remain in orbit. Interplanetary Travel : Rockets must surpass the second cosmic velocity to travel to other planets. Interstellar Missions : Missions like Voyager 1 have exceeded the third cosmic velocity to escape the Solar System. Python Implementation import numpy as np import matplotlib.pyplot as plt def cosmic_velocities(M, R): G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) v1 = np.sqrt(G * M / R) # First cosmic velocity v2 = np.sqrt(2) * v1 # Second cosmic velocity return v1, v2 # Celestial bodies (mass in kg, radius in meters) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.3895e6), \"Jupiter\": (1.898e27, 6.9911e7) } velocities = {body: cosmic_velocities(*bodies[body]) for body in bodies} # Plotting labels = list(velocities.keys()) v1_values = [velocities[b][0] for b in labels] v2_values = [velocities[b][1] for b in labels] x = np.arange(len(labels)) plt.figure(figsize=(8, 6)) plt.bar(x - 0.2, v1_values, 0.4, label='First Cosmic Velocity') plt.bar(x + 0.2, v2_values, 0.4, label='Second Cosmic Velocity') plt.xticks(x, labels) plt.xlabel('Celestial Body') plt.ylabel('Velocity (m/s)') plt.title('Cosmic Velocities for Different Celestial Bodies') plt.legend() plt.grid() plt.show() Results and Observations Earth : First cosmic velocity \u2248 7.91 km/s, escape velocity \u2248 11.2 km/s. Mars : First cosmic velocity \u2248 3.55 km/s, escape velocity \u2248 5.03 km/s. Jupiter : First cosmic velocity","title":"Problem 2"},{"location":"1Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation"},{"location":"1Physics/2%20Gravity/Problem_2/#task","text":"","title":"Task"},{"location":"1Physics/2%20Gravity/Problem_2/#1-definition-of-cosmic-velocities","text":"First Cosmic Velocity (Orbital Velocity) : The minimum velocity required to maintain a stable circular orbit around a celestial body. [ v_1 = \\sqrt{\\frac{GM}{r}} ] Second Cosmic Velocity (Escape Velocity) : The minimum velocity needed to escape a celestial body's gravitational field without further propulsion. [ v_2 = \\sqrt{\\frac{2GM}{r}} = \\sqrt{2} v_1 ] Third Cosmic Velocity (Interstellar Escape Velocity) : The velocity required to escape the gravitational pull of a star system. [ v 3 = \\sqrt{\\frac{2G M {sun}}{r_{orbit}}} ] (For a planet escaping the Solar System)","title":"1. Definition of Cosmic Velocities"},{"location":"1Physics/2%20Gravity/Problem_2/#2-mathematical-analysis-and-influencing-parameters","text":"The gravitational constant \\( G = 6.67430 \\times 10^{-11} \\) \\(m^3 kg^{-1} s^{-2}\\) . The mass \\( M \\) of the celestial body significantly affects escape velocity. The radius \\( r \\) of the celestial body determines the strength of gravity at its surface.","title":"2. Mathematical Analysis and Influencing Parameters"},{"location":"1Physics/2%20Gravity/Problem_2/#3-real-world-applications","text":"Launching Satellites : Achieving the first cosmic velocity allows satellites to remain in orbit. Interplanetary Travel : Rockets must surpass the second cosmic velocity to travel to other planets. Interstellar Missions : Missions like Voyager 1 have exceeded the third cosmic velocity to escape the Solar System.","title":"3. Real-World Applications"},{"location":"1Physics/2%20Gravity/Problem_2/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt def cosmic_velocities(M, R): G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) v1 = np.sqrt(G * M / R) # First cosmic velocity v2 = np.sqrt(2) * v1 # Second cosmic velocity return v1, v2 # Celestial bodies (mass in kg, radius in meters) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.3895e6), \"Jupiter\": (1.898e27, 6.9911e7) } velocities = {body: cosmic_velocities(*bodies[body]) for body in bodies} # Plotting labels = list(velocities.keys()) v1_values = [velocities[b][0] for b in labels] v2_values = [velocities[b][1] for b in labels] x = np.arange(len(labels)) plt.figure(figsize=(8, 6)) plt.bar(x - 0.2, v1_values, 0.4, label='First Cosmic Velocity') plt.bar(x + 0.2, v2_values, 0.4, label='Second Cosmic Velocity') plt.xticks(x, labels) plt.xlabel('Celestial Body') plt.ylabel('Velocity (m/s)') plt.title('Cosmic Velocities for Different Celestial Bodies') plt.legend() plt.grid() plt.show()","title":"Python Implementation"},{"location":"1Physics/2%20Gravity/Problem_2/#results-and-observations","text":"Earth : First cosmic velocity \u2248 7.91 km/s, escape velocity \u2248 11.2 km/s. Mars : First cosmic velocity \u2248 3.55 km/s, escape velocity \u2248 5.03 km/s. Jupiter : First cosmic velocity","title":"Results and Observations"},{"location":"1Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth. Task 1. Types of Possible Trajectories Elliptical Orbit : If the payload's velocity is below escape velocity but above circular orbit velocity, it enters an elliptical orbit. Parabolic Trajectory : If the velocity equals the escape velocity, the payload follows a parabolic trajectory and escapes Earth\u2019s gravity. Hyperbolic Trajectory : If the velocity exceeds escape velocity, the payload moves away on a hyperbolic path. Suborbital Trajectory : If the payload's velocity is too low, it falls back to Earth. 2. Mathematical Formulation Newton\u2019s Law of Gravitation : [ F = \\frac{GMm}{r^2} ] Equation of Motion : [ m \\frac{d^2 r}{dt^2} = - \\frac{GMm}{r^2} ] Orbital Energy Equation : [ E = \\frac{1}{2} m v^2 - \\frac{GMm}{r} ] where \\(E\\) determines the type of trajectory: If \\( E < 0 \\) , the orbit is elliptical . If \\( E = 0 \\) , the trajectory is parabolic . If \\( E > 0 \\) , the trajectory is hyperbolic . 3. Numerical Simulation Compute the trajectory using numerical integration (Runge-Kutta method). Simulate different initial conditions (altitude, velocity, direction). Visualize the resulting paths. Python Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6.371e6 # Radius of Earth (m) # Equations of motion def equations(t, y): x, vx, y, vy = y r = np.sqrt(x**2 + y**2) ax = -G * M_earth * x / r**3 ay = -G * M_earth * y / r**3 return [vx, ax, vy, ay] # Initial conditions (position in meters, velocity in m/s) altitude = 400e3 # 400 km above Earth initial_speed = 7800 # Close to low Earth orbit velocity initial_angle = np.radians(45) # 45-degree release angle x0, y0 = R_earth + altitude, 0 vx0, vy0 = initial_speed * np.cos(initial_angle), initial_speed * np.sin(initial_angle) # Time span t_span = (0, 10000) t_eval = np.linspace(*t_span, 1000) # Solve equations sol = solve_ivp(equations, t_span, [x0, vx0, y0, vy0], t_eval=t_eval) # Plot trajectory plt.figure(figsize=(8, 8)) plt.plot(sol.y[0], sol.y[2], label='Payload Trajectory') plt.plot(0, 0, 'ro', label='Earth') plt.xlabel('x position (m)') plt.ylabel('y position (m)') plt.legend() plt.title('Simulated Trajectory of a Released Payload') plt.grid() plt.show() Results and Observations By adjusting the initial velocity and angle, different trajectories are obtained. If the velocity is too low , the payload falls back to Earth. At the orbital velocity , the payload stays in orbit. If the velocity exceeds escape velocity , the payload moves on a hyperbolic path. Applications in Space Missions Satellite Deployment : Adjusting release velocity ensures successful orbit insertion. Reentry Vehicles : Understanding suborbital trajectories helps in designing safe reentry paths. Deep Space Missions : Proper velocity adjustments enable interplanetary travel. Conclusion Simulating payload trajectories helps in mission planning and space exploration. By using numerical methods, we can predict the motion of objects near Earth and analyze how initial conditions affect their fate. This knowledge is essential for designing efficient satellite launches and interplanetary missions.","title":"Problem 3"},{"location":"1Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth.","title":"Motivation"},{"location":"1Physics/2%20Gravity/Problem_3/#task","text":"","title":"Task"},{"location":"1Physics/2%20Gravity/Problem_3/#1-types-of-possible-trajectories","text":"Elliptical Orbit : If the payload's velocity is below escape velocity but above circular orbit velocity, it enters an elliptical orbit. Parabolic Trajectory : If the velocity equals the escape velocity, the payload follows a parabolic trajectory and escapes Earth\u2019s gravity. Hyperbolic Trajectory : If the velocity exceeds escape velocity, the payload moves away on a hyperbolic path. Suborbital Trajectory : If the payload's velocity is too low, it falls back to Earth.","title":"1. Types of Possible Trajectories"},{"location":"1Physics/2%20Gravity/Problem_3/#2-mathematical-formulation","text":"Newton\u2019s Law of Gravitation : [ F = \\frac{GMm}{r^2} ] Equation of Motion : [ m \\frac{d^2 r}{dt^2} = - \\frac{GMm}{r^2} ] Orbital Energy Equation : [ E = \\frac{1}{2} m v^2 - \\frac{GMm}{r} ] where \\(E\\) determines the type of trajectory: If \\( E < 0 \\) , the orbit is elliptical . If \\( E = 0 \\) , the trajectory is parabolic . If \\( E > 0 \\) , the trajectory is hyperbolic .","title":"2. Mathematical Formulation"},{"location":"1Physics/2%20Gravity/Problem_3/#3-numerical-simulation","text":"Compute the trajectory using numerical integration (Runge-Kutta method). Simulate different initial conditions (altitude, velocity, direction). Visualize the resulting paths.","title":"3. Numerical Simulation"},{"location":"1Physics/2%20Gravity/Problem_3/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6.371e6 # Radius of Earth (m) # Equations of motion def equations(t, y): x, vx, y, vy = y r = np.sqrt(x**2 + y**2) ax = -G * M_earth * x / r**3 ay = -G * M_earth * y / r**3 return [vx, ax, vy, ay] # Initial conditions (position in meters, velocity in m/s) altitude = 400e3 # 400 km above Earth initial_speed = 7800 # Close to low Earth orbit velocity initial_angle = np.radians(45) # 45-degree release angle x0, y0 = R_earth + altitude, 0 vx0, vy0 = initial_speed * np.cos(initial_angle), initial_speed * np.sin(initial_angle) # Time span t_span = (0, 10000) t_eval = np.linspace(*t_span, 1000) # Solve equations sol = solve_ivp(equations, t_span, [x0, vx0, y0, vy0], t_eval=t_eval) # Plot trajectory plt.figure(figsize=(8, 8)) plt.plot(sol.y[0], sol.y[2], label='Payload Trajectory') plt.plot(0, 0, 'ro', label='Earth') plt.xlabel('x position (m)') plt.ylabel('y position (m)') plt.legend() plt.title('Simulated Trajectory of a Released Payload') plt.grid() plt.show()","title":"Python Implementation"},{"location":"1Physics/2%20Gravity/Problem_3/#results-and-observations","text":"By adjusting the initial velocity and angle, different trajectories are obtained. If the velocity is too low , the payload falls back to Earth. At the orbital velocity , the payload stays in orbit. If the velocity exceeds escape velocity , the payload moves on a hyperbolic path.","title":"Results and Observations"},{"location":"1Physics/2%20Gravity/Problem_3/#applications-in-space-missions","text":"Satellite Deployment : Adjusting release velocity ensures successful orbit insertion. Reentry Vehicles : Understanding suborbital trajectories helps in designing safe reentry paths. Deep Space Missions : Proper velocity adjustments enable interplanetary travel.","title":"Applications in Space Missions"},{"location":"1Physics/2%20Gravity/Problem_3/#conclusion","text":"Simulating payload trajectories helps in mission planning and space exploration. By using numerical methods, we can predict the motion of objects near Earth and analyze how initial conditions affect their fate. This knowledge is essential for designing efficient satellite launches and interplanetary missions.","title":"Conclusion"},{"location":"1Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3Discret_Mathematics/1%20Set%20Theory%20and/_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3Discret_Mathematics/1%20Set%20Theory%20and/_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3Discret_Mathematics/1%20Set%20Theory%20and/_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3Discret_Mathematics/1%20Set%20Theory%20and/_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3Discret_Mathematics/1%20Set%20Theory%20and/_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3Discret_Mathematics/1%20Set%20Theory%20and/_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3Discret_Mathematics/2%20Number%20Theory%20and/_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3Discret_Mathematics/2%20Number%20Theory%20and/_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3Discret_Mathematics/2%20Number%20Theory%20and/_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3Discret_Mathematics/2%20Number%20Theory%20and/_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3Discret_Mathematics/3%20Recurrence%20and/_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3Discret_Mathematics/3%20Recurrence%20and/_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3Discret_Mathematics/3%20Recurrence%20and/_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3Discret_Mathematics/3%20Recurrence%20and/_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3Discret_Mathematics/3%20Recurrence%20and/_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3Discret_Mathematics/3%20Recurrence%20and/_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3Discret_Mathematics/4%20Graph%20Theory%20and/_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3Discret_Mathematics/4%20Graph%20Theory%20and/_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}