{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. The equations governing projectile motion involve both linear and quadratic relationships, making them accessible yet deeply insightful. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket. Task 1. Theoretical Foundation Derive the governing equations of motion from fundamental principles. Solve the basic differential equation to establish the general form of the motion. Highlight how variations in initial conditions lead to a family of solutions. 2. Analysis of the Range Investigate how the horizontal range depends on the angle of projection. Discuss how changes in other parameters, such as initial velocity and gravitational acceleration, influence the relationship. 3. Practical Applications Reflect on how this model can be adapted to describe various real-world situations, such as projectiles launched on uneven terrain or in the presence of air resistance. 4. Implementation Develop a computational tool or algorithm to simulate projectile motion. Visualize the range as a function of the angle of projection for different sets of initial conditions. Governing Equations The equations for projectile motion under the influence of gravity (neglecting air resistance) are: [ x = v_0 \\cos(\\theta) t ] [ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 ] The time of flight is given by: \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] The range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation shows that the maximum range is achieved at \\( \\theta = 45^\\circ \\) . Python Implementation import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, g=9.81): angles = np.linspace(0, 90, num=100) ranges = (v0**2 * np.sin(np.radians(2 * angles))) / g plt.figure(figsize=(8, 6)) plt.plot(angles, ranges, label=f'Initial Velocity = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Angle of Projection') plt.legend() plt.grid() plt.show() # Example usage projectile_range(v0=20) Examples Examples 1. Basic Projectile Trajectories Comparison of trajectories at 30\u00b0, 45\u00b0, and 60\u00b0 launch angles 2. Range vs Angle Graph Theoretical range as function of launch angle (peaks at 45\u00b0) 3. Effect of Air Resistance Red: Ideal vacuum trajectory; Blue: Real-world trajectory with air resistance 4. Projectile Equations Diagram Visual representation of projectile motion equations 5. Uneven Terrain Example Projectile launched from elevated position showing asymmetric range Results and Observations The range follows a symmetric pattern, peaking at \\(45^\\circ\\) . Higher initial velocity increases the maximum range. Changing gravity (e.g., different planets) alters the range behavior. Limitations and Further Considerations Air resistance is neglected in this model. Uneven terrain is not accounted for. Real-world effects like wind and spin could be included in a more advanced model. Conclusion This study of projectile motion highlights the elegance of physics and the practical implications of mathematical models. By extending this analysis to include drag or varying gravitational fields, we can better understand complex real-world scenarios, from sports to aerospace engineering.","title":"Problem 1"},{"location":"1Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. The equations governing projectile motion involve both linear and quadratic relationships, making them accessible yet deeply insightful. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket.","title":"Motivation"},{"location":"1Physics/1%20Mechanics/Problem_1/#task","text":"","title":"Task"},{"location":"1Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Derive the governing equations of motion from fundamental principles. Solve the basic differential equation to establish the general form of the motion. Highlight how variations in initial conditions lead to a family of solutions.","title":"1. Theoretical Foundation"},{"location":"1Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"Investigate how the horizontal range depends on the angle of projection. Discuss how changes in other parameters, such as initial velocity and gravitational acceleration, influence the relationship.","title":"2. Analysis of the Range"},{"location":"1Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Reflect on how this model can be adapted to describe various real-world situations, such as projectiles launched on uneven terrain or in the presence of air resistance.","title":"3. Practical Applications"},{"location":"1Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Develop a computational tool or algorithm to simulate projectile motion. Visualize the range as a function of the angle of projection for different sets of initial conditions.","title":"4. Implementation"},{"location":"1Physics/1%20Mechanics/Problem_1/#governing-equations","text":"The equations for projectile motion under the influence of gravity (neglecting air resistance) are: [ x = v_0 \\cos(\\theta) t ] [ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 ] The time of flight is given by: \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] The range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation shows that the maximum range is achieved at \\( \\theta = 45^\\circ \\) .","title":"Governing Equations"},{"location":"1Physics/1%20Mechanics/Problem_1/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, g=9.81): angles = np.linspace(0, 90, num=100) ranges = (v0**2 * np.sin(np.radians(2 * angles))) / g plt.figure(figsize=(8, 6)) plt.plot(angles, ranges, label=f'Initial Velocity = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Angle of Projection') plt.legend() plt.grid() plt.show() # Example usage projectile_range(v0=20)","title":"Python Implementation"},{"location":"1Physics/1%20Mechanics/Problem_1/#examples","text":"","title":"Examples"},{"location":"1Physics/1%20Mechanics/Problem_1/#examples_1","text":"","title":"Examples"},{"location":"1Physics/1%20Mechanics/Problem_1/#1-basic-projectile-trajectories","text":"Comparison of trajectories at 30\u00b0, 45\u00b0, and 60\u00b0 launch angles","title":"1. Basic Projectile Trajectories"},{"location":"1Physics/1%20Mechanics/Problem_1/#2-range-vs-angle-graph","text":"Theoretical range as function of launch angle (peaks at 45\u00b0)","title":"2. Range vs Angle Graph"},{"location":"1Physics/1%20Mechanics/Problem_1/#3-effect-of-air-resistance","text":"Red: Ideal vacuum trajectory; Blue: Real-world trajectory with air resistance","title":"3. Effect of Air Resistance"},{"location":"1Physics/1%20Mechanics/Problem_1/#4-projectile-equations-diagram","text":"Visual representation of projectile motion equations","title":"4. Projectile Equations Diagram"},{"location":"1Physics/1%20Mechanics/Problem_1/#5-uneven-terrain-example","text":"Projectile launched from elevated position showing asymmetric range","title":"5. Uneven Terrain Example"},{"location":"1Physics/1%20Mechanics/Problem_1/#results-and-observations","text":"The range follows a symmetric pattern, peaking at \\(45^\\circ\\) . Higher initial velocity increases the maximum range. Changing gravity (e.g., different planets) alters the range behavior.","title":"Results and Observations"},{"location":"1Physics/1%20Mechanics/Problem_1/#limitations-and-further-considerations","text":"Air resistance is neglected in this model. Uneven terrain is not accounted for. Real-world effects like wind and spin could be included in a more advanced model.","title":"Limitations and Further Considerations"},{"location":"1Physics/1%20Mechanics/Problem_1/#conclusion","text":"This study of projectile motion highlights the elegance of physics and the practical implications of mathematical models. By extending this analysis to include drag or varying gravitational fields, we can better understand complex real-world scenarios, from sports to aerospace engineering.","title":"Conclusion"},{"location":"1Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping, restoring forces, and external driving forces. By introducing both damping and external periodic forcing, the system demonstrates a transition from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena serve as a foundation for understanding complex real-world systems, such as driven oscillators, climate systems, and mechanical structures under periodic stress. Adding forcing introduces new parameters, such as the amplitude and frequency of the external force, which significantly affect the pendulum's behavior. By systematically varying these parameters, a diverse class of solutions can be observed, including synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors not only highlight fundamental physics principles but also provide insights into engineering applications such as energy harvesting, vibration isolation, and mechanical resonance. Task 1. Theoretical Foundation Start with the differential equation governing the motion of a forced damped pendulum: [ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) ] Derive the approximate solutions for small-angle oscillations. Explore resonance conditions and their implications for the system's energy. 2. Analysis of Dynamics Investigate how the damping coefficient, driving amplitude, and driving frequency influence the motion of the pendulum. Examine the transition between regular and chaotic motion and their physical interpretations. 3. Practical Applications Discuss real-world scenarios where the forced damped pendulum model applies, such as in energy harvesting devices, suspension bridges, and oscillating circuits. 4. Implementation Create a computational model to simulate the motion of a forced damped pendulum. Visualize the behavior under various damping, driving force, and initial conditions. Plot phase diagrams and Poincar\u00e9 sections to illustrate transitions to chaos. Examples 1. Phase Portrait of Damped Pendulum Trajectories in (\u03b8, \u03c9) phase space showing attractor behavior 2. Resonance Response Curve Amplitude vs. driving frequency showing resonance peak 3. Chaotic Behavior Strange attractor in parameter space for chaotic regime 4. Time Series Solutions Displacement \u03b8(t) showing transient and steady-state behavior 5. Bifurcation Diagram Transition to chaos as driving force increases 6. Poincar\u00e9 Section Stroboscopic sampling revealing underlying structure 7. Experimental Setup Typical laboratory apparatus for forced pendulum studies Governing Equations and Approximations For small angles ( \\( \\theta \\approx \\sin\\theta \\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] The steady-state solution can be found using methods like the method of undetermined coefficients or Fourier analysis. Python Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def forced_damped_pendulum(t, y, beta, omega0, A, omega): theta, omega_dot = y return [omega_dot, -beta * omega_dot - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] # Parameters beta = 0.5 # Damping coefficient omega0 = 1.5 # Natural frequency A = 1.2 # Forcing amplitude omega = 2.0 # Driving frequency y0 = [0.2, 0] # Initial conditions (angle, angular velocity) tspan = (0, 50) t_eval = np.linspace(*tspan, 1000) sol = solve_ivp(forced_damped_pendulum, tspan, y0, t_eval=t_eval, args=(beta, omega0, A, omega)) # Plot results plt.figure(figsize=(8, 6)) plt.plot(sol.t, sol.y[0], label='Theta (angle)') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() Results and Observations The motion depends critically on the damping and forcing parameters. Resonance occurs when \\( \\omega \\approx \\omega_0 \\) , leading to large oscillations. Chaos emerges for certain parameter ranges, leading to unpredictable behavior. Advanced Analysis Phase Portraits : Visualize trajectories in phase space. Poincar\u00e9 Sections : Analyze periodicity and chaos. Bifurcation Diagrams : Examine how the system's stability changes with varying parameters. Limitations and Further Considerations Nonlinear damping and external perturbations can be incorporated for realism. Higher-order numerical methods may improve accuracy in chaotic regimes. Real-world applications require considering material properties and external noise. Conclusion The forced damped pendulum serves as a gateway to understanding nonlinear dynamics, chaos, and resonance. By extending this study with computational simulations and advanced mathematical tools, deeper insights into real-world oscillatory systems can be achieved.","title":"Problem 2"},{"location":"1Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping, restoring forces, and external driving forces. By introducing both damping and external periodic forcing, the system demonstrates a transition from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena serve as a foundation for understanding complex real-world systems, such as driven oscillators, climate systems, and mechanical structures under periodic stress. Adding forcing introduces new parameters, such as the amplitude and frequency of the external force, which significantly affect the pendulum's behavior. By systematically varying these parameters, a diverse class of solutions can be observed, including synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors not only highlight fundamental physics principles but also provide insights into engineering applications such as energy harvesting, vibration isolation, and mechanical resonance.","title":"Motivation"},{"location":"1Physics/1%20Mechanics/Problem_2/#task","text":"","title":"Task"},{"location":"1Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"Start with the differential equation governing the motion of a forced damped pendulum: [ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) ] Derive the approximate solutions for small-angle oscillations. Explore resonance conditions and their implications for the system's energy.","title":"1. Theoretical Foundation"},{"location":"1Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Investigate how the damping coefficient, driving amplitude, and driving frequency influence the motion of the pendulum. Examine the transition between regular and chaotic motion and their physical interpretations.","title":"2. Analysis of Dynamics"},{"location":"1Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Discuss real-world scenarios where the forced damped pendulum model applies, such as in energy harvesting devices, suspension bridges, and oscillating circuits.","title":"3. Practical Applications"},{"location":"1Physics/1%20Mechanics/Problem_2/#4-implementation","text":"Create a computational model to simulate the motion of a forced damped pendulum. Visualize the behavior under various damping, driving force, and initial conditions. Plot phase diagrams and Poincar\u00e9 sections to illustrate transitions to chaos.","title":"4. Implementation"},{"location":"1Physics/1%20Mechanics/Problem_2/#examples","text":"","title":"Examples"},{"location":"1Physics/1%20Mechanics/Problem_2/#1-phase-portrait-of-damped-pendulum","text":"Trajectories in (\u03b8, \u03c9) phase space showing attractor behavior","title":"1. Phase Portrait of Damped Pendulum"},{"location":"1Physics/1%20Mechanics/Problem_2/#2-resonance-response-curve","text":"Amplitude vs. driving frequency showing resonance peak","title":"2. Resonance Response Curve"},{"location":"1Physics/1%20Mechanics/Problem_2/#3-chaotic-behavior","text":"Strange attractor in parameter space for chaotic regime","title":"3. Chaotic Behavior"},{"location":"1Physics/1%20Mechanics/Problem_2/#4-time-series-solutions","text":"Displacement \u03b8(t) showing transient and steady-state behavior","title":"4. Time Series Solutions"},{"location":"1Physics/1%20Mechanics/Problem_2/#5-bifurcation-diagram","text":"Transition to chaos as driving force increases","title":"5. Bifurcation Diagram"},{"location":"1Physics/1%20Mechanics/Problem_2/#6-poincare-section","text":"Stroboscopic sampling revealing underlying structure","title":"6. Poincar\u00e9 Section"},{"location":"1Physics/1%20Mechanics/Problem_2/#7-experimental-setup","text":"Typical laboratory apparatus for forced pendulum studies","title":"7. Experimental Setup"},{"location":"1Physics/1%20Mechanics/Problem_2/#governing-equations-and-approximations","text":"For small angles ( \\( \\theta \\approx \\sin\\theta \\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] The steady-state solution can be found using methods like the method of undetermined coefficients or Fourier analysis.","title":"Governing Equations and Approximations"},{"location":"1Physics/1%20Mechanics/Problem_2/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def forced_damped_pendulum(t, y, beta, omega0, A, omega): theta, omega_dot = y return [omega_dot, -beta * omega_dot - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] # Parameters beta = 0.5 # Damping coefficient omega0 = 1.5 # Natural frequency A = 1.2 # Forcing amplitude omega = 2.0 # Driving frequency y0 = [0.2, 0] # Initial conditions (angle, angular velocity) tspan = (0, 50) t_eval = np.linspace(*tspan, 1000) sol = solve_ivp(forced_damped_pendulum, tspan, y0, t_eval=t_eval, args=(beta, omega0, A, omega)) # Plot results plt.figure(figsize=(8, 6)) plt.plot(sol.t, sol.y[0], label='Theta (angle)') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show()","title":"Python Implementation"},{"location":"1Physics/1%20Mechanics/Problem_2/#results-and-observations","text":"The motion depends critically on the damping and forcing parameters. Resonance occurs when \\( \\omega \\approx \\omega_0 \\) , leading to large oscillations. Chaos emerges for certain parameter ranges, leading to unpredictable behavior.","title":"Results and Observations"},{"location":"1Physics/1%20Mechanics/Problem_2/#advanced-analysis","text":"Phase Portraits : Visualize trajectories in phase space. Poincar\u00e9 Sections : Analyze periodicity and chaos. Bifurcation Diagrams : Examine how the system's stability changes with varying parameters.","title":"Advanced Analysis"},{"location":"1Physics/1%20Mechanics/Problem_2/#limitations-and-further-considerations","text":"Nonlinear damping and external perturbations can be incorporated for realism. Higher-order numerical methods may improve accuracy in chaotic regimes. Real-world applications require considering material properties and external noise.","title":"Limitations and Further Considerations"},{"location":"1Physics/1%20Mechanics/Problem_2/#conclusion","text":"The forced damped pendulum serves as a gateway to understanding nonlinear dynamics, chaos, and resonance. By extending this study with computational simulations and advanced mathematical tools, deeper insights into real-world oscillatory systems can be achieved.","title":"Conclusion"},{"location":"1Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law, is a cornerstone of celestial mechanics. This simple yet profound relationship allows for the determination of planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. By analyzing this relationship, one can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems. Task 1. Theoretical Foundation Start with Newton's Law of Gravitation and centripetal force: [ F = \\frac{G M m}{r^2} ] [ F = m \\frac{v^2}{r} ] Equating the two forces for circular orbits and expressing velocity in terms of the orbital period \\(T\\) : [ v = \\frac{2 \\pi r}{T} ] [ \\frac{G M m}{r^2} = m \\frac{(2 \\pi r / T)^2}{r} ] Simplifying gives Kepler\u2019s Third Law: [ T^2 = \\frac{4 \\pi^2 r^3}{G M} ] 2. Implications in Astronomy This relationship allows astronomers to determine planetary masses and distances without direct measurements. It explains why outer planets have longer orbital periods. Used in exoplanet detection and understanding binary star systems. 3. Real-World Examples Earth-Moon System : Applying the law to determine the Moon\u2019s distance. Solar System : Predicting planetary orbits using known masses. Satellite Orbits : Verifying geostationary orbit conditions. 4. Computational Implementation Simulating circular orbits using Newton\u2019s equations. Verifying Kepler\u2019s Third Law numerically. Examples 1. Kepler's Third Law Visualization Graphical representation of T\u00b2 \u221d r\u00b3 relationship 2. Solar System Orbits Relative orbital radii and periods of planets 3. Binary Star System Mutual orbit with common center of mass 4. Geostationary Orbit Special case where T = 24 hours (r \u2248 42,164 km) 5. Moon's Orbit T = 27.3 days, r \u2248 384,400 km 6. Exoplanet Transit Data Period detection from observed transits 7. Hohmann Transfer Orbit Orbital period matching for efficient transfers Python Implementation import numpy as np import matplotlib.pyplot as plt def kepler_law(r, M, G=6.67430e-11): return np.sqrt((4 * np.pi**2 * r**3) / (G * M)) # Example: Earth orbiting the Sun M_sun = 1.989e30 # Mass of the Sun in kg r_values = np.linspace(1e10, 1e12, 100) # Orbital radii in meters T_values = kepler_law(r_values, M_sun) plt.figure(figsize=(8, 6)) plt.plot(r_values, T_values**2, label='T^2 vs. r^3') plt.xlabel('Orbital Radius (m)') plt.ylabel('Orbital Period Squared (s^2)') plt.title(\"Kepler's Third Law: T^2 vs. r^3\") plt.legend() plt.grid() plt.show() Results and Observations The graph confirms the linearity between \\(T^2\\) and \\(r^3\\) . Increasing mass \\(M\\) decreases orbital periods for a given radius. Satellites closer to Earth have shorter periods than distant ones. Extension to Elliptical Orbits Kepler\u2019s Third Law holds for elliptical orbits by considering the semi-major axis \\(a\\) instead of \\(r\\) . Used in analyzing asteroid belts and multi-star systems. Conclusion Kepler\u2019s Third Law is fundamental in celestial mechanics, bridging theoretical physics with astronomical observations. By leveraging computational models, we can extend these principles to predict and analyze a variety of orbital phenomena, from planetary motion to artificial satellite deployment.","title":"Problem 1"},{"location":"1Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law, is a cornerstone of celestial mechanics. This simple yet profound relationship allows for the determination of planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. By analyzing this relationship, one can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems.","title":"Motivation"},{"location":"1Physics/2%20Gravity/Problem_1/#task","text":"","title":"Task"},{"location":"1Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","text":"Start with Newton's Law of Gravitation and centripetal force: [ F = \\frac{G M m}{r^2} ] [ F = m \\frac{v^2}{r} ] Equating the two forces for circular orbits and expressing velocity in terms of the orbital period \\(T\\) : [ v = \\frac{2 \\pi r}{T} ] [ \\frac{G M m}{r^2} = m \\frac{(2 \\pi r / T)^2}{r} ] Simplifying gives Kepler\u2019s Third Law: [ T^2 = \\frac{4 \\pi^2 r^3}{G M} ]","title":"1. Theoretical Foundation"},{"location":"1Physics/2%20Gravity/Problem_1/#2-implications-in-astronomy","text":"This relationship allows astronomers to determine planetary masses and distances without direct measurements. It explains why outer planets have longer orbital periods. Used in exoplanet detection and understanding binary star systems.","title":"2. Implications in Astronomy"},{"location":"1Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"Earth-Moon System : Applying the law to determine the Moon\u2019s distance. Solar System : Predicting planetary orbits using known masses. Satellite Orbits : Verifying geostationary orbit conditions.","title":"3. Real-World Examples"},{"location":"1Physics/2%20Gravity/Problem_1/#4-computational-implementation","text":"Simulating circular orbits using Newton\u2019s equations. Verifying Kepler\u2019s Third Law numerically.","title":"4. Computational Implementation"},{"location":"1Physics/2%20Gravity/Problem_1/#examples","text":"","title":"Examples"},{"location":"1Physics/2%20Gravity/Problem_1/#1-keplers-third-law-visualization","text":"Graphical representation of T\u00b2 \u221d r\u00b3 relationship","title":"1. Kepler's Third Law Visualization"},{"location":"1Physics/2%20Gravity/Problem_1/#2-solar-system-orbits","text":"Relative orbital radii and periods of planets","title":"2. Solar System Orbits"},{"location":"1Physics/2%20Gravity/Problem_1/#3-binary-star-system","text":"Mutual orbit with common center of mass","title":"3. Binary Star System"},{"location":"1Physics/2%20Gravity/Problem_1/#4-geostationary-orbit","text":"Special case where T = 24 hours (r \u2248 42,164 km)","title":"4. Geostationary Orbit"},{"location":"1Physics/2%20Gravity/Problem_1/#5-moons-orbit","text":"T = 27.3 days, r \u2248 384,400 km","title":"5. Moon's Orbit"},{"location":"1Physics/2%20Gravity/Problem_1/#6-exoplanet-transit-data","text":"Period detection from observed transits","title":"6. Exoplanet Transit Data"},{"location":"1Physics/2%20Gravity/Problem_1/#7-hohmann-transfer-orbit","text":"Orbital period matching for efficient transfers","title":"7. Hohmann Transfer Orbit"},{"location":"1Physics/2%20Gravity/Problem_1/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt def kepler_law(r, M, G=6.67430e-11): return np.sqrt((4 * np.pi**2 * r**3) / (G * M)) # Example: Earth orbiting the Sun M_sun = 1.989e30 # Mass of the Sun in kg r_values = np.linspace(1e10, 1e12, 100) # Orbital radii in meters T_values = kepler_law(r_values, M_sun) plt.figure(figsize=(8, 6)) plt.plot(r_values, T_values**2, label='T^2 vs. r^3') plt.xlabel('Orbital Radius (m)') plt.ylabel('Orbital Period Squared (s^2)') plt.title(\"Kepler's Third Law: T^2 vs. r^3\") plt.legend() plt.grid() plt.show()","title":"Python Implementation"},{"location":"1Physics/2%20Gravity/Problem_1/#results-and-observations","text":"The graph confirms the linearity between \\(T^2\\) and \\(r^3\\) . Increasing mass \\(M\\) decreases orbital periods for a given radius. Satellites closer to Earth have shorter periods than distant ones.","title":"Results and Observations"},{"location":"1Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"Kepler\u2019s Third Law holds for elliptical orbits by considering the semi-major axis \\(a\\) instead of \\(r\\) . Used in analyzing asteroid belts and multi-star systems.","title":"Extension to Elliptical Orbits"},{"location":"1Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler\u2019s Third Law is fundamental in celestial mechanics, bridging theoretical physics with astronomical observations. By leveraging computational models, we can extend these principles to predict and analyze a variety of orbital phenomena, from planetary motion to artificial satellite deployment.","title":"Conclusion"},{"location":"1Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Task 1. Definition of Cosmic Velocities First Cosmic Velocity (Orbital Velocity) : The minimum velocity required to maintain a stable circular orbit around a celestial body. [ v_1 = \\sqrt{\\frac{GM}{r}} ] Second Cosmic Velocity (Escape Velocity) : The minimum velocity needed to escape a celestial body's gravitational field without further propulsion. [ v_2 = \\sqrt{\\frac{2GM}{r}} = \\sqrt{2} v_1 ] Third Cosmic Velocity (Interstellar Escape Velocity) : The velocity required to escape the gravitational pull of a star system. [ v 3 = \\sqrt{\\frac{2G M {sun}}{r_{orbit}}} ] (For a planet escaping the Solar System) 2. Mathematical Analysis and Influencing Parameters The gravitational constant \\( G = 6.67430 \\times 10^{-11} \\) \\(m^3 kg^{-1} s^{-2}\\) . The mass \\( M \\) of the celestial body significantly affects escape velocity. The radius \\( r \\) of the celestial body determines the strength of gravity at its surface. Examples 1. Solar System Escape Velocities Comparative escape velocities from planetary surfaces (Earth: 11.2 km/s, Moon: 2.4 km/s) 2. Earth's Gravity Well Visualization of escape velocity as \"climbing out\" of a gravity well 3. Cosmic Velocity Chart The four cosmic velocities (V\u2081-V\u2084) for Earth 4. Black Hole Event Horizon Where escape velocity exceeds speed of light (V\u2091\u209b\u1d04 > c) 5. Rocket Launch Trajectories How different velocities achieve orbit (V\u2081) vs. escape (V\u2082) 6. Exoplanet Escape Calculations Atmospheric escape when V\u2091\u209b\u1d04 < thermal velocity 7. Relativistic Escape Einstein-adapted escape velocity at extreme gravity 3. Real-World Applications Launching Satellites : Achieving the first cosmic velocity allows satellites to remain in orbit. Interplanetary Travel : Rockets must surpass the second cosmic velocity to travel to other planets. Interstellar Missions : Missions like Voyager 1 have exceeded the third cosmic velocity to escape the Solar System. Python Implementation import numpy as np import matplotlib.pyplot as plt def cosmic_velocities(M, R): G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) v1 = np.sqrt(G * M / R) # First cosmic velocity v2 = np.sqrt(2) * v1 # Second cosmic velocity return v1, v2 # Celestial bodies (mass in kg, radius in meters) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.3895e6), \"Jupiter\": (1.898e27, 6.9911e7) } velocities = {body: cosmic_velocities(*bodies[body]) for body in bodies} # Plotting labels = list(velocities.keys()) v1_values = [velocities[b][0] for b in labels] v2_values = [velocities[b][1] for b in labels] x = np.arange(len(labels)) plt.figure(figsize=(8, 6)) plt.bar(x - 0.2, v1_values, 0.4, label='First Cosmic Velocity') plt.bar(x + 0.2, v2_values, 0.4, label='Second Cosmic Velocity') plt.xticks(x, labels) plt.xlabel('Celestial Body') plt.ylabel('Velocity (m/s)') plt.title('Cosmic Velocities for Different Celestial Bodies') plt.legend() plt.grid() plt.show() Results and Observations Earth : First cosmic velocity \u2248 7.91 km/s, escape velocity \u2248 11.2 km/s. Mars : First cosmic velocity \u2248 3.55 km/s, escape velocity \u2248 5.03 km/s. Jupiter : First cosmic velocity","title":"Problem 2"},{"location":"1Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation"},{"location":"1Physics/2%20Gravity/Problem_2/#task","text":"","title":"Task"},{"location":"1Physics/2%20Gravity/Problem_2/#1-definition-of-cosmic-velocities","text":"First Cosmic Velocity (Orbital Velocity) : The minimum velocity required to maintain a stable circular orbit around a celestial body. [ v_1 = \\sqrt{\\frac{GM}{r}} ] Second Cosmic Velocity (Escape Velocity) : The minimum velocity needed to escape a celestial body's gravitational field without further propulsion. [ v_2 = \\sqrt{\\frac{2GM}{r}} = \\sqrt{2} v_1 ] Third Cosmic Velocity (Interstellar Escape Velocity) : The velocity required to escape the gravitational pull of a star system. [ v 3 = \\sqrt{\\frac{2G M {sun}}{r_{orbit}}} ] (For a planet escaping the Solar System)","title":"1. Definition of Cosmic Velocities"},{"location":"1Physics/2%20Gravity/Problem_2/#2-mathematical-analysis-and-influencing-parameters","text":"The gravitational constant \\( G = 6.67430 \\times 10^{-11} \\) \\(m^3 kg^{-1} s^{-2}\\) . The mass \\( M \\) of the celestial body significantly affects escape velocity. The radius \\( r \\) of the celestial body determines the strength of gravity at its surface.","title":"2. Mathematical Analysis and Influencing Parameters"},{"location":"1Physics/2%20Gravity/Problem_2/#examples","text":"","title":"Examples"},{"location":"1Physics/2%20Gravity/Problem_2/#1-solar-system-escape-velocities","text":"Comparative escape velocities from planetary surfaces (Earth: 11.2 km/s, Moon: 2.4 km/s)","title":"1. Solar System Escape Velocities"},{"location":"1Physics/2%20Gravity/Problem_2/#2-earths-gravity-well","text":"Visualization of escape velocity as \"climbing out\" of a gravity well","title":"2. Earth's Gravity Well"},{"location":"1Physics/2%20Gravity/Problem_2/#3-cosmic-velocity-chart","text":"The four cosmic velocities (V\u2081-V\u2084) for Earth","title":"3. Cosmic Velocity Chart"},{"location":"1Physics/2%20Gravity/Problem_2/#4-black-hole-event-horizon","text":"Where escape velocity exceeds speed of light (V\u2091\u209b\u1d04 > c)","title":"4. Black Hole Event Horizon"},{"location":"1Physics/2%20Gravity/Problem_2/#5-rocket-launch-trajectories","text":"How different velocities achieve orbit (V\u2081) vs. escape (V\u2082)","title":"5. Rocket Launch Trajectories"},{"location":"1Physics/2%20Gravity/Problem_2/#6-exoplanet-escape-calculations","text":"Atmospheric escape when V\u2091\u209b\u1d04 < thermal velocity","title":"6. Exoplanet Escape Calculations"},{"location":"1Physics/2%20Gravity/Problem_2/#7-relativistic-escape","text":"Einstein-adapted escape velocity at extreme gravity","title":"7. Relativistic Escape"},{"location":"1Physics/2%20Gravity/Problem_2/#3-real-world-applications","text":"Launching Satellites : Achieving the first cosmic velocity allows satellites to remain in orbit. Interplanetary Travel : Rockets must surpass the second cosmic velocity to travel to other planets. Interstellar Missions : Missions like Voyager 1 have exceeded the third cosmic velocity to escape the Solar System.","title":"3. Real-World Applications"},{"location":"1Physics/2%20Gravity/Problem_2/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt def cosmic_velocities(M, R): G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) v1 = np.sqrt(G * M / R) # First cosmic velocity v2 = np.sqrt(2) * v1 # Second cosmic velocity return v1, v2 # Celestial bodies (mass in kg, radius in meters) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.3895e6), \"Jupiter\": (1.898e27, 6.9911e7) } velocities = {body: cosmic_velocities(*bodies[body]) for body in bodies} # Plotting labels = list(velocities.keys()) v1_values = [velocities[b][0] for b in labels] v2_values = [velocities[b][1] for b in labels] x = np.arange(len(labels)) plt.figure(figsize=(8, 6)) plt.bar(x - 0.2, v1_values, 0.4, label='First Cosmic Velocity') plt.bar(x + 0.2, v2_values, 0.4, label='Second Cosmic Velocity') plt.xticks(x, labels) plt.xlabel('Celestial Body') plt.ylabel('Velocity (m/s)') plt.title('Cosmic Velocities for Different Celestial Bodies') plt.legend() plt.grid() plt.show()","title":"Python Implementation"},{"location":"1Physics/2%20Gravity/Problem_2/#results-and-observations","text":"Earth : First cosmic velocity \u2248 7.91 km/s, escape velocity \u2248 11.2 km/s. Mars : First cosmic velocity \u2248 3.55 km/s, escape velocity \u2248 5.03 km/s. Jupiter : First cosmic velocity","title":"Results and Observations"},{"location":"1Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth. Task 1. Types of Possible Trajectories Elliptical Orbit : If the payload's velocity is below escape velocity but above circular orbit velocity, it enters an elliptical orbit. Parabolic Trajectory : If the velocity equals the escape velocity, the payload follows a parabolic trajectory and escapes Earth\u2019s gravity. Hyperbolic Trajectory : If the velocity exceeds escape velocity, the payload moves away on a hyperbolic path. Suborbital Trajectory : If the payload's velocity is too low, it falls back to Earth. 2. Mathematical Formulation Newton\u2019s Law of Gravitation : [ F = \\frac{GMm}{r^2} ] Equation of Motion : [ m \\frac{d^2 r}{dt^2} = - \\frac{GMm}{r^2} ] Orbital Energy Equation : [ E = \\frac{1}{2} m v^2 - \\frac{GMm}{r} ] where \\(E\\) determines the type of trajectory: If \\( E < 0 \\) , the orbit is elliptical . If \\( E = 0 \\) , the trajectory is parabolic . If \\( E > 0 \\) , the trajectory is hyperbolic . 3. Numerical Simulation Compute the trajectory using numerical integration (Runge-Kutta method). Simulate different initial conditions (altitude, velocity, direction). Visualize the resulting paths. Examples 1. Ideal Parabolic Trajectory Perfect parabolic path in vacuum (no air resistance) 2. Coriolis Deflection Eastward drift due to Earth's rotation (~1.4 cm per 100m drop at equator) 3. High-Altitude Release Transition from parabolic to elliptical motion above 100km 4. ISS Payload Release Hyperbolic relative trajectory when released from 7.66 km/s orbital velocity 5. Terminal Velocity Transition to constant velocity (~90 m/s for skydiver posture) 6. Guided vs Ballistic Descent Parafoil (blue) vs uncontrolled (red) trajectories 7. Reentry Physics Plasma sheath formation during high-speed atmospheric entry Key Equations Free-fall time: t = sqrt(2h/g) Coriolis deflection: d = (1/3)\u03c9gt\u00b3cos\u03bb Terminal velocity: v\u209c = sqrt(2mg/\u03c1AC\u209a) Python Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6.371e6 # Radius of Earth (m) # Equations of motion def equations(t, y): x, vx, y, vy = y r = np.sqrt(x**2 + y**2) ax = -G * M_earth * x / r**3 ay = -G * M_earth * y / r**3 return [vx, ax, vy, ay] # Initial conditions (position in meters, velocity in m/s) altitude = 400e3 # 400 km above Earth initial_speed = 7800 # Close to low Earth orbit velocity initial_angle = np.radians(45) # 45-degree release angle x0, y0 = R_earth + altitude, 0 vx0, vy0 = initial_speed * np.cos(initial_angle), initial_speed * np.sin(initial_angle) # Time span t_span = (0, 10000) t_eval = np.linspace(*t_span, 1000) # Solve equations sol = solve_ivp(equations, t_span, [x0, vx0, y0, vy0], t_eval=t_eval) # Plot trajectory plt.figure(figsize=(8, 8)) plt.plot(sol.y[0], sol.y[2], label='Payload Trajectory') plt.plot(0, 0, 'ro', label='Earth') plt.xlabel('x position (m)') plt.ylabel('y position (m)') plt.legend() plt.title('Simulated Trajectory of a Released Payload') plt.grid() plt.show() Results and Observations By adjusting the initial velocity and angle, different trajectories are obtained. If the velocity is too low , the payload falls back to Earth. At the orbital velocity , the payload stays in orbit. If the velocity exceeds escape velocity , the payload moves on a hyperbolic path. Applications in Space Missions Satellite Deployment : Adjusting release velocity ensures successful orbit insertion. Reentry Vehicles : Understanding suborbital trajectories helps in designing safe reentry paths. Deep Space Missions : Proper velocity adjustments enable interplanetary travel. Conclusion Simulating payload trajectories helps in mission planning and space exploration. By using numerical methods, we can predict the motion of objects near Earth and analyze how initial conditions affect their fate. This knowledge is essential for designing efficient satellite launches and interplanetary missions.","title":"Problem 3"},{"location":"1Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth.","title":"Motivation"},{"location":"1Physics/2%20Gravity/Problem_3/#task","text":"","title":"Task"},{"location":"1Physics/2%20Gravity/Problem_3/#1-types-of-possible-trajectories","text":"Elliptical Orbit : If the payload's velocity is below escape velocity but above circular orbit velocity, it enters an elliptical orbit. Parabolic Trajectory : If the velocity equals the escape velocity, the payload follows a parabolic trajectory and escapes Earth\u2019s gravity. Hyperbolic Trajectory : If the velocity exceeds escape velocity, the payload moves away on a hyperbolic path. Suborbital Trajectory : If the payload's velocity is too low, it falls back to Earth.","title":"1. Types of Possible Trajectories"},{"location":"1Physics/2%20Gravity/Problem_3/#2-mathematical-formulation","text":"Newton\u2019s Law of Gravitation : [ F = \\frac{GMm}{r^2} ] Equation of Motion : [ m \\frac{d^2 r}{dt^2} = - \\frac{GMm}{r^2} ] Orbital Energy Equation : [ E = \\frac{1}{2} m v^2 - \\frac{GMm}{r} ] where \\(E\\) determines the type of trajectory: If \\( E < 0 \\) , the orbit is elliptical . If \\( E = 0 \\) , the trajectory is parabolic . If \\( E > 0 \\) , the trajectory is hyperbolic .","title":"2. Mathematical Formulation"},{"location":"1Physics/2%20Gravity/Problem_3/#3-numerical-simulation","text":"Compute the trajectory using numerical integration (Runge-Kutta method). Simulate different initial conditions (altitude, velocity, direction). Visualize the resulting paths.","title":"3. Numerical Simulation"},{"location":"1Physics/2%20Gravity/Problem_3/#examples","text":"","title":"Examples"},{"location":"1Physics/2%20Gravity/Problem_3/#1-ideal-parabolic-trajectory","text":"Perfect parabolic path in vacuum (no air resistance)","title":"1. Ideal Parabolic Trajectory"},{"location":"1Physics/2%20Gravity/Problem_3/#2-coriolis-deflection","text":"Eastward drift due to Earth's rotation (~1.4 cm per 100m drop at equator)","title":"2. Coriolis Deflection"},{"location":"1Physics/2%20Gravity/Problem_3/#3-high-altitude-release","text":"Transition from parabolic to elliptical motion above 100km","title":"3. High-Altitude Release"},{"location":"1Physics/2%20Gravity/Problem_3/#4-iss-payload-release","text":"Hyperbolic relative trajectory when released from 7.66 km/s orbital velocity","title":"4. ISS Payload Release"},{"location":"1Physics/2%20Gravity/Problem_3/#5-terminal-velocity","text":"Transition to constant velocity (~90 m/s for skydiver posture)","title":"5. Terminal Velocity"},{"location":"1Physics/2%20Gravity/Problem_3/#6-guided-vs-ballistic-descent","text":"Parafoil (blue) vs uncontrolled (red) trajectories","title":"6. Guided vs Ballistic Descent"},{"location":"1Physics/2%20Gravity/Problem_3/#7-reentry-physics","text":"Plasma sheath formation during high-speed atmospheric entry","title":"7. Reentry Physics"},{"location":"1Physics/2%20Gravity/Problem_3/#key-equations","text":"Free-fall time: t = sqrt(2h/g) Coriolis deflection: d = (1/3)\u03c9gt\u00b3cos\u03bb Terminal velocity: v\u209c = sqrt(2mg/\u03c1AC\u209a)","title":"Key Equations"},{"location":"1Physics/2%20Gravity/Problem_3/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6.371e6 # Radius of Earth (m) # Equations of motion def equations(t, y): x, vx, y, vy = y r = np.sqrt(x**2 + y**2) ax = -G * M_earth * x / r**3 ay = -G * M_earth * y / r**3 return [vx, ax, vy, ay] # Initial conditions (position in meters, velocity in m/s) altitude = 400e3 # 400 km above Earth initial_speed = 7800 # Close to low Earth orbit velocity initial_angle = np.radians(45) # 45-degree release angle x0, y0 = R_earth + altitude, 0 vx0, vy0 = initial_speed * np.cos(initial_angle), initial_speed * np.sin(initial_angle) # Time span t_span = (0, 10000) t_eval = np.linspace(*t_span, 1000) # Solve equations sol = solve_ivp(equations, t_span, [x0, vx0, y0, vy0], t_eval=t_eval) # Plot trajectory plt.figure(figsize=(8, 8)) plt.plot(sol.y[0], sol.y[2], label='Payload Trajectory') plt.plot(0, 0, 'ro', label='Earth') plt.xlabel('x position (m)') plt.ylabel('y position (m)') plt.legend() plt.title('Simulated Trajectory of a Released Payload') plt.grid() plt.show()","title":"Python Implementation"},{"location":"1Physics/2%20Gravity/Problem_3/#results-and-observations","text":"By adjusting the initial velocity and angle, different trajectories are obtained. If the velocity is too low , the payload falls back to Earth. At the orbital velocity , the payload stays in orbit. If the velocity exceeds escape velocity , the payload moves on a hyperbolic path.","title":"Results and Observations"},{"location":"1Physics/2%20Gravity/Problem_3/#applications-in-space-missions","text":"Satellite Deployment : Adjusting release velocity ensures successful orbit insertion. Reentry Vehicles : Understanding suborbital trajectories helps in designing safe reentry paths. Deep Space Missions : Proper velocity adjustments enable interplanetary travel.","title":"Applications in Space Missions"},{"location":"1Physics/2%20Gravity/Problem_3/#conclusion","text":"Simulating payload trajectories helps in mission planning and space exploration. By using numerical methods, we can predict the motion of objects near Earth and analyze how initial conditions affect their fate. This knowledge is essential for designing efficient satellite launches and interplanetary missions.","title":"Conclusion"},{"location":"1Physics/3%20Waves/Problem_1/","text":"Problem 1 Waves: Interference Patterns on a Water Surface Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be easily observed when ripples from different points meet, forming distinctive interference patterns. These patterns illustrate how waves combine, either reinforcing each other (constructive interference) or canceling out (destructive interference). Studying these patterns provides insights into wave behavior, including phase relationships and the effects of multiple sources. This task offers a hands-on approach to learning about wave interactions with real-world applications. Task We analyze the interference patterns formed on a water surface due to the superposition of waves emitted from point sources positioned at the vertices of a regular polygon. Mathematical Model A circular wave originating from a point source at \\( (x_i, y_i) \\) follows the equation: \\[ u_i(x, y, t) = A \\cos(k r_i - \\omega t + \\phi_0) \\] where: \\( u_i(x, y, t) \\) is the displacement of the water surface at point \\( (x, y) \\) and time \\( t \\) , \\( A \\) is the amplitude of the wave, \\( k = \\frac{2\\pi}{\\lambda} \\) is the wave number, \\( \\omega = 2\\pi f \\) is the angular frequency, \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) is the distance from the source to the point \\( (x, y) \\) , \\( \\phi_0 \\) is the initial phase. The total displacement due to multiple sources (placed at polygon vertices) is: \\[ U(x, y, t) = \\sum\\_{i=1}^{N} u_i(x, y, t) \\] where \\( N \\) is the number of wave sources (vertices of the polygon). Steps to Follow Choose a Regular Polygon : Select a polygon (triangle, square, pentagon, etc.). Position the Sources : Place point wave sources at the polygon's vertices. Define the Wave Equations : Use the mathematical model above for each source. Superposition of Waves : Sum the wave displacements at each grid point. Visualize Interference Patterns : Plot the results graphically. Python Implementation The following Python script simulates interference patterns for waves from sources positioned at the vertices of a regular polygon. import numpy as np import matplotlib.pyplot as plt # Parameters A = 1 # Amplitude wavelength = 2 # Wavelength k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi # Angular frequency phi_0 = 0 # Initial phase time = 0 # Time snapshot # Define polygon vertices N = 5 # Number of sources (e.g., pentagon) radius = 5 angles = np.linspace(0, 2 * np.pi, N, endpoint=False) source_positions = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Grid setup x = np.linspace(-10, 10, 400) y = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x, y) # Compute superposition of waves U = np.zeros_like(X) for (x_i, y_i) in source_positions: r = np.sqrt((X - x_i)**2 + (Y - y_i)**2) U += A * np.cos(k * r - omega * time + phi_0) # Plot interference pattern plt.figure(figsize=(8, 6)) plt.contourf(X, Y, U, levels=100, cmap='RdBu_r') plt.colorbar(label='Wave Amplitude') plt.scatter(*zip(*source_positions), color='black', marker='o', label='Wave Sources') plt.legend() plt.title(\"Interference Pattern of Waves from Regular Polygon Sources\") plt.xlabel(\"X Position\") plt.ylabel(\"Y Position\") plt.show() Results and Observations The simulation results reveal distinct interference patterns: Constructive Interference : Bright regions where waves amplify each other. Destructive Interference : Dark regions where waves cancel out. Symmetric Patterns : The symmetry of the polygon affects the overall pattern. Example images illustrating interference patterns: Equilateral Triangle Interference Square Wave Interference Pentagon Wave Interference Conclusion This study demonstrates how multiple wave sources interact to create complex interference patterns. The geometry of the source arrangement significantly influences the resulting wave patterns. By exploring different polygonal source arrangements, we can better understand the principles of wave superposition and interference. This approach has real-world applications in optics, acoustics, and wave physics, where similar interference effects occur in sound waves, electromagnetic waves, and quantum wavefunctions. Further Exploration Investigate how phase differences between sources alter the interference pattern. Explore the effect of different wavelengths on pattern formation. Extend the model to simulate 3D wave interference.","title":"Problem 1"},{"location":"1Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1Physics/3%20Waves/Problem_1/#waves-interference-patterns-on-a-water-surface","text":"","title":"Waves: Interference Patterns on a Water Surface"},{"location":"1Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be easily observed when ripples from different points meet, forming distinctive interference patterns. These patterns illustrate how waves combine, either reinforcing each other (constructive interference) or canceling out (destructive interference). Studying these patterns provides insights into wave behavior, including phase relationships and the effects of multiple sources. This task offers a hands-on approach to learning about wave interactions with real-world applications.","title":"Motivation"},{"location":"1Physics/3%20Waves/Problem_1/#task","text":"We analyze the interference patterns formed on a water surface due to the superposition of waves emitted from point sources positioned at the vertices of a regular polygon.","title":"Task"},{"location":"1Physics/3%20Waves/Problem_1/#mathematical-model","text":"A circular wave originating from a point source at \\( (x_i, y_i) \\) follows the equation: \\[ u_i(x, y, t) = A \\cos(k r_i - \\omega t + \\phi_0) \\] where: \\( u_i(x, y, t) \\) is the displacement of the water surface at point \\( (x, y) \\) and time \\( t \\) , \\( A \\) is the amplitude of the wave, \\( k = \\frac{2\\pi}{\\lambda} \\) is the wave number, \\( \\omega = 2\\pi f \\) is the angular frequency, \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) is the distance from the source to the point \\( (x, y) \\) , \\( \\phi_0 \\) is the initial phase. The total displacement due to multiple sources (placed at polygon vertices) is: \\[ U(x, y, t) = \\sum\\_{i=1}^{N} u_i(x, y, t) \\] where \\( N \\) is the number of wave sources (vertices of the polygon).","title":"Mathematical Model"},{"location":"1Physics/3%20Waves/Problem_1/#steps-to-follow","text":"Choose a Regular Polygon : Select a polygon (triangle, square, pentagon, etc.). Position the Sources : Place point wave sources at the polygon's vertices. Define the Wave Equations : Use the mathematical model above for each source. Superposition of Waves : Sum the wave displacements at each grid point. Visualize Interference Patterns : Plot the results graphically.","title":"Steps to Follow"},{"location":"1Physics/3%20Waves/Problem_1/#python-implementation","text":"The following Python script simulates interference patterns for waves from sources positioned at the vertices of a regular polygon. import numpy as np import matplotlib.pyplot as plt # Parameters A = 1 # Amplitude wavelength = 2 # Wavelength k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi # Angular frequency phi_0 = 0 # Initial phase time = 0 # Time snapshot # Define polygon vertices N = 5 # Number of sources (e.g., pentagon) radius = 5 angles = np.linspace(0, 2 * np.pi, N, endpoint=False) source_positions = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Grid setup x = np.linspace(-10, 10, 400) y = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x, y) # Compute superposition of waves U = np.zeros_like(X) for (x_i, y_i) in source_positions: r = np.sqrt((X - x_i)**2 + (Y - y_i)**2) U += A * np.cos(k * r - omega * time + phi_0) # Plot interference pattern plt.figure(figsize=(8, 6)) plt.contourf(X, Y, U, levels=100, cmap='RdBu_r') plt.colorbar(label='Wave Amplitude') plt.scatter(*zip(*source_positions), color='black', marker='o', label='Wave Sources') plt.legend() plt.title(\"Interference Pattern of Waves from Regular Polygon Sources\") plt.xlabel(\"X Position\") plt.ylabel(\"Y Position\") plt.show()","title":"Python Implementation"},{"location":"1Physics/3%20Waves/Problem_1/#results-and-observations","text":"The simulation results reveal distinct interference patterns: Constructive Interference : Bright regions where waves amplify each other. Destructive Interference : Dark regions where waves cancel out. Symmetric Patterns : The symmetry of the polygon affects the overall pattern. Example images illustrating interference patterns: Equilateral Triangle Interference Square Wave Interference Pentagon Wave Interference","title":"Results and Observations"},{"location":"1Physics/3%20Waves/Problem_1/#conclusion","text":"This study demonstrates how multiple wave sources interact to create complex interference patterns. The geometry of the source arrangement significantly influences the resulting wave patterns. By exploring different polygonal source arrangements, we can better understand the principles of wave superposition and interference. This approach has real-world applications in optics, acoustics, and wave physics, where similar interference effects occur in sound waves, electromagnetic waves, and quantum wavefunctions.","title":"Conclusion"},{"location":"1Physics/3%20Waves/Problem_1/#further-exploration","text":"Investigate how phase differences between sources alter the interference pattern. Explore the effect of different wavelengths on pattern formation. Extend the model to simulate 3D wave interference.","title":"Further Exploration"},{"location":"1Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 \ud83d\ude80 Lorentz Force Simulation Project \ud83d\udd0d Problem Overview The Lorentz force governs the motion of charged particles in the presence of electric ( \\( \\vec{E} \\) ) and magnetic ( \\( \\vec{B} \\) ) fields. The force is given by: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This force plays a crucial role in numerous real-world applications such as particle accelerators, plasma confinement, and mass spectrometry. 1\ufe0f\u20e3 Applications of Lorentz Force Real-World Systems Particle Accelerators : Use electric fields to accelerate and magnetic fields to steer charged particles. Mass Spectrometers : Separate ions based on their mass-to-charge ratio via deflection in a magnetic field. Magnetic Confinement in Fusion : Tokamaks and stellarators use magnetic fields to trap hot plasma. Role of Fields Electric Fields : Change particle energy (accelerate or decelerate). Magnetic Fields : Change particle direction (circular or helical motion), but not speed. 2\ufe0f\u20e3 Simulation of Particle Motion \ud83d\udd27 Tools Numerical Integration : 4th-order Runge-Kutta Libraries : NumPy, Matplotlib, mpl_toolkits for 3D \ud83e\uddea Scenarios Uniform Magnetic Field Combined Electric and Magnetic Fields Crossed Fields import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def lorentz_force(q, E, B, v): return q * (E + np.cross(v, B)) def runge_kutta_step(pos, vel, dt, q, m, E, B): def acceleration(v): return lorentz_force(q, E, B, v) / m k1v = dt * acceleration(vel) k1x = dt * vel k2v = dt * acceleration(vel + 0.5 * k1v) k2x = dt * (vel + 0.5 * k1v) k3v = dt * acceleration(vel + 0.5 * k2v) k3x = dt * (vel + 0.5 * k2v) k4v = dt * acceleration(vel + k3v) k4x = dt * (vel + k3v) vel_new = vel + (k1v + 2*k2v + 2*k3v + k4v) / 6 pos_new = pos + (k1x + 2*k2x + 2*k3x + k4x) / 6 return pos_new, vel_new def simulate(q, m, E, B, v0, r0, dt, steps): traj = np.zeros((steps, 3)) pos, vel = r0, v0 for i in range(steps): traj[i] = pos pos, vel = runge_kutta_step(pos, vel, dt, q, m, E, B) return traj # Parameters q = 1.0 # Charge m = 1.0 # Mass B = np.array([0, 0, 1]) E = np.array([0, 0, 0]) v0 = np.array([1, 1, 0]) r0 = np.array([0, 0, 0]) dt = 0.01 steps = 2000 trajectory = simulate(q, m, E, B, v0, r0, dt, steps) # Plotting fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:,0], trajectory[:,1], trajectory[:,2]) ax.set_title(\"Charged Particle Trajectory in Magnetic Field\") ax.set_xlabel(\"X\") ax.set_ylabel(\"Y\") ax.set_zlabel(\"Z\") plt.tight_layout() plt.show() 3\ufe0f\u20e3 Parameter Exploration Parameter Description Effect B , E Field Strengths Radius and path shape v0 Initial velocity vector Determines pitch of helix q , m Charge and mass Affects curvature (via force) Example Tweaks : Change E to simulate drift in crossed fields. Modify q/m to observe tighter or wider spirals. 4\ufe0f\u20e3 Visualizations \ud83c\udf00 Pure Magnetic Field (Circular/Helical) \u26a1 Crossed Fields (E\u00d7B Drift) \ud83c\udfaf Custom Simulation Output (Generated by the provided script; include generated image here if running in notebook) \ud83e\udde0 Interpretation and Real-World Links Cyclotron Radius (Larmor Radius) : [ r = \\frac{mv_\\perp}{qB} ] Drift Velocity in crossed fields: [ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} ] Used in: Cyclotrons : Exploit circular motion from magnetic fields to accelerate particles. Plasma Traps : Use E\u00d7B drift to contain ions. \ud83d\udca1 Extensions Simulate non-uniform fields (e.g., magnetic mirror). Add relativistic effects for high-speed particles. Use real mass/charge values (e.g., electron, proton). \ud83d\udcc1 Deliverables \u2705 Python code for simulation. \u2705 Plots for various field configurations. \u2705 Physical interpretation and application discussion.","title":"Problem 1"},{"location":"1Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1Physics/4%20Electromagnetism/Problem_1/#lorentz-force-simulation-project","text":"","title":"\ud83d\ude80 Lorentz Force Simulation Project"},{"location":"1Physics/4%20Electromagnetism/Problem_1/#problem-overview","text":"The Lorentz force governs the motion of charged particles in the presence of electric ( \\( \\vec{E} \\) ) and magnetic ( \\( \\vec{B} \\) ) fields. The force is given by: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This force plays a crucial role in numerous real-world applications such as particle accelerators, plasma confinement, and mass spectrometry.","title":"\ud83d\udd0d Problem Overview"},{"location":"1Physics/4%20Electromagnetism/Problem_1/#1-applications-of-lorentz-force","text":"","title":"1\ufe0f\u20e3 Applications of Lorentz Force"},{"location":"1Physics/4%20Electromagnetism/Problem_1/#real-world-systems","text":"Particle Accelerators : Use electric fields to accelerate and magnetic fields to steer charged particles. Mass Spectrometers : Separate ions based on their mass-to-charge ratio via deflection in a magnetic field. Magnetic Confinement in Fusion : Tokamaks and stellarators use magnetic fields to trap hot plasma.","title":"Real-World Systems"},{"location":"1Physics/4%20Electromagnetism/Problem_1/#role-of-fields","text":"Electric Fields : Change particle energy (accelerate or decelerate). Magnetic Fields : Change particle direction (circular or helical motion), but not speed.","title":"Role of Fields"},{"location":"1Physics/4%20Electromagnetism/Problem_1/#2-simulation-of-particle-motion","text":"","title":"2\ufe0f\u20e3 Simulation of Particle Motion"},{"location":"1Physics/4%20Electromagnetism/Problem_1/#tools","text":"Numerical Integration : 4th-order Runge-Kutta Libraries : NumPy, Matplotlib, mpl_toolkits for 3D","title":"\ud83d\udd27 Tools"},{"location":"1Physics/4%20Electromagnetism/Problem_1/#scenarios","text":"Uniform Magnetic Field Combined Electric and Magnetic Fields Crossed Fields import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def lorentz_force(q, E, B, v): return q * (E + np.cross(v, B)) def runge_kutta_step(pos, vel, dt, q, m, E, B): def acceleration(v): return lorentz_force(q, E, B, v) / m k1v = dt * acceleration(vel) k1x = dt * vel k2v = dt * acceleration(vel + 0.5 * k1v) k2x = dt * (vel + 0.5 * k1v) k3v = dt * acceleration(vel + 0.5 * k2v) k3x = dt * (vel + 0.5 * k2v) k4v = dt * acceleration(vel + k3v) k4x = dt * (vel + k3v) vel_new = vel + (k1v + 2*k2v + 2*k3v + k4v) / 6 pos_new = pos + (k1x + 2*k2x + 2*k3x + k4x) / 6 return pos_new, vel_new def simulate(q, m, E, B, v0, r0, dt, steps): traj = np.zeros((steps, 3)) pos, vel = r0, v0 for i in range(steps): traj[i] = pos pos, vel = runge_kutta_step(pos, vel, dt, q, m, E, B) return traj # Parameters q = 1.0 # Charge m = 1.0 # Mass B = np.array([0, 0, 1]) E = np.array([0, 0, 0]) v0 = np.array([1, 1, 0]) r0 = np.array([0, 0, 0]) dt = 0.01 steps = 2000 trajectory = simulate(q, m, E, B, v0, r0, dt, steps) # Plotting fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:,0], trajectory[:,1], trajectory[:,2]) ax.set_title(\"Charged Particle Trajectory in Magnetic Field\") ax.set_xlabel(\"X\") ax.set_ylabel(\"Y\") ax.set_zlabel(\"Z\") plt.tight_layout() plt.show()","title":"\ud83e\uddea Scenarios"},{"location":"1Physics/4%20Electromagnetism/Problem_1/#3-parameter-exploration","text":"Parameter Description Effect B , E Field Strengths Radius and path shape v0 Initial velocity vector Determines pitch of helix q , m Charge and mass Affects curvature (via force) Example Tweaks : Change E to simulate drift in crossed fields. Modify q/m to observe tighter or wider spirals.","title":"3\ufe0f\u20e3 Parameter Exploration"},{"location":"1Physics/4%20Electromagnetism/Problem_1/#4-visualizations","text":"","title":"4\ufe0f\u20e3 Visualizations"},{"location":"1Physics/4%20Electromagnetism/Problem_1/#pure-magnetic-field-circularhelical","text":"","title":"\ud83c\udf00 Pure Magnetic Field (Circular/Helical)"},{"location":"1Physics/4%20Electromagnetism/Problem_1/#crossed-fields-eb-drift","text":"","title":"\u26a1 Crossed Fields (E\u00d7B Drift)"},{"location":"1Physics/4%20Electromagnetism/Problem_1/#custom-simulation-output","text":"(Generated by the provided script; include generated image here if running in notebook)","title":"\ud83c\udfaf Custom Simulation Output"},{"location":"1Physics/4%20Electromagnetism/Problem_1/#interpretation-and-real-world-links","text":"Cyclotron Radius (Larmor Radius) : [ r = \\frac{mv_\\perp}{qB} ] Drift Velocity in crossed fields: [ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} ] Used in: Cyclotrons : Exploit circular motion from magnetic fields to accelerate particles. Plasma Traps : Use E\u00d7B drift to contain ions.","title":"\ud83e\udde0 Interpretation and Real-World Links"},{"location":"1Physics/4%20Electromagnetism/Problem_1/#extensions","text":"Simulate non-uniform fields (e.g., magnetic mirror). Add relativistic effects for high-speed particles. Use real mass/charge values (e.g., electron, proton).","title":"\ud83d\udca1 Extensions"},{"location":"1Physics/4%20Electromagnetism/Problem_1/#deliverables","text":"\u2705 Python code for simulation. \u2705 Plots for various field configurations. \u2705 Physical interpretation and application discussion.","title":"\ud83d\udcc1 Deliverables"},{"location":"1Physics/5%20Circuits/Problem_1/","text":"\ud83d\udd0c Problem 1: Equivalent Resistance Using Graph Theory \ud83c\udfaf Motivation Computing the equivalent resistance of an electrical circuit is a fundamental problem in electronics. While basic circuits with few resistors can be simplified using series and parallel rules, large or complex networks quickly become intractable without a systematic approach. This is where graph theory comes in. By modeling a circuit as a graph , we can automate and simplify the process of finding equivalent resistance between any two points. \ud83d\udd39 Nodes (Vertices) represent junctions or connection points. \ud83d\udd38 Edges represent resistors with weights corresponding to resistance values (in ohms, \u2126). This graph-based model is used in: Circuit analysis software (e.g., SPICE) Electrical design automation (EDA) Network analysis and optimization Physics simulations \u2699\ufe0f Conceptual Overview \ud83d\udd01 Two Key Simplifications 1. Series Reduction Two resistors connected end-to-end between three nodes (A-B-C), where the middle node has only two connections (degree 2), can be replaced with a single resistor. Formula : \\(R_{eq} = R_1 + R_2\\) Illustration: A \u2014[5\u03a9]\u2014 B \u2014[3\u03a9]\u2014 C \u279e A \u2014[8\u03a9]\u2014 C 2. Parallel Reduction Resistors connecting the same two nodes (e.g., A and B) can be replaced with a single resistor using the parallel formula: Formula : \\(\\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots + \\frac{1}{R_n}\\) Illustration: A \u2014[6\u03a9]\u2014 B A \u2014[3\u03a9]\u2014 B \u279e A \u2014[2\u03a9]\u2014 B \ud83d\udd0d Problem Example \ud83c\udfaf Goal: Find the equivalent resistance between nodes A and D Initial Circuit Diagram: A | [2\u03a9] | B / \\ [4\u03a9] [6\u03a9] / \\ C \u2014\u2014[3\u03a9]\u2014\u2014 D Graph View: Nodes: A, B, C, D Edges: A\u2014B: 2\u03a9 B\u2014C: 4\u03a9 B\u2014D: 6\u03a9 C\u2014D: 3\u03a9 \ud83d\udd27 Step-by-Step Simplification B\u2014C\u2014D forms a triangle with B\u2014D First reduce C\u2014D: no simplification yet Use Delta-to-Wye transformation if necessary Apply parallel reduction between paths to D Then, compute the total resistance from A to D Note: For complex networks, advanced transformations like Delta-Wye (\u0394-Y) may be needed. \ud83e\udde0 Algorithm: Graph-Based Simplification We can automate the reduction using a loop that simplifies until no further changes are possible. \ud83e\uddfe Pseudocode function simplify_graph(G): repeat for each node in G: if node has degree 2: check for series configuration: replace with single resistor (R1 + R2) for each pair of nodes (u, v): if multiple resistors exist: replace with equivalent parallel resistor until no more simplifications return resistance between source and target \ud83d\udcca Illustration: Example Before and After Before Simplification: Graph: (weighted undirected) A \u2014(2\u03a9)\u2014 B B \u2014(4\u03a9)\u2014 C B \u2014(6\u03a9)\u2014 D C \u2014(3\u03a9)\u2014 D After Simplification: Equivalent graph (conceptual): A \u2014[R_eq]\u2014 D \ud83e\uddf0 Use Cases and Extensions \ud83d\udd0c Electrical Engineering Design Tools \ud83d\udda5\ufe0f Circuit Simulation and Visualization Software \ud83d\udcd0 Symbolic Circuit Analysis (algebraic manipulation) \ud83e\uddee Support for AC circuits and impedance (Z = R + jX) \ud83d\udd01 Integration with Kirchhoff's laws and mesh analysis \u26a1 Advanced: Delta-Wye Transformations and matrix-based reductions \ud83e\udde9 Advanced Concepts Kirchhoff's Laws : Model using linear algebra Laplacian Matrix : Resistance as function of inverse Laplacian Delta-Wye Transformations : For reducing triangular subgraphs Interested in implementation? Ask for Python/NumPy code or an interactive visualization! \ud83d\udccc Summary Graph theory offers a structured, repeatable, and automatable method to calculate equivalent resistance in electrical networks. It scales better than manual series-parallel techniques and provides the foundation for modern circuit analysis software. Use it to: Simplify large resistor networks Automate design verification Teach concepts interactively Let me know if you'd like this as a visual Markdown file with embedded diagrams or code samples!","title":"\ud83d\udd0c Problem 1: Equivalent Resistance Using Graph Theory"},{"location":"1Physics/5%20Circuits/Problem_1/#problem-1-equivalent-resistance-using-graph-theory","text":"","title":"\ud83d\udd0c Problem 1: Equivalent Resistance Using Graph Theory"},{"location":"1Physics/5%20Circuits/Problem_1/#motivation","text":"Computing the equivalent resistance of an electrical circuit is a fundamental problem in electronics. While basic circuits with few resistors can be simplified using series and parallel rules, large or complex networks quickly become intractable without a systematic approach. This is where graph theory comes in. By modeling a circuit as a graph , we can automate and simplify the process of finding equivalent resistance between any two points. \ud83d\udd39 Nodes (Vertices) represent junctions or connection points. \ud83d\udd38 Edges represent resistors with weights corresponding to resistance values (in ohms, \u2126). This graph-based model is used in: Circuit analysis software (e.g., SPICE) Electrical design automation (EDA) Network analysis and optimization Physics simulations","title":"\ud83c\udfaf Motivation"},{"location":"1Physics/5%20Circuits/Problem_1/#conceptual-overview","text":"","title":"\u2699\ufe0f Conceptual Overview"},{"location":"1Physics/5%20Circuits/Problem_1/#two-key-simplifications","text":"","title":"\ud83d\udd01 Two Key Simplifications"},{"location":"1Physics/5%20Circuits/Problem_1/#1-series-reduction","text":"Two resistors connected end-to-end between three nodes (A-B-C), where the middle node has only two connections (degree 2), can be replaced with a single resistor. Formula : \\(R_{eq} = R_1 + R_2\\) Illustration: A \u2014[5\u03a9]\u2014 B \u2014[3\u03a9]\u2014 C \u279e A \u2014[8\u03a9]\u2014 C","title":"1. Series Reduction"},{"location":"1Physics/5%20Circuits/Problem_1/#2-parallel-reduction","text":"Resistors connecting the same two nodes (e.g., A and B) can be replaced with a single resistor using the parallel formula: Formula : \\(\\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots + \\frac{1}{R_n}\\) Illustration: A \u2014[6\u03a9]\u2014 B A \u2014[3\u03a9]\u2014 B \u279e A \u2014[2\u03a9]\u2014 B","title":"2. Parallel Reduction"},{"location":"1Physics/5%20Circuits/Problem_1/#problem-example","text":"","title":"\ud83d\udd0d Problem Example"},{"location":"1Physics/5%20Circuits/Problem_1/#goal-find-the-equivalent-resistance-between-nodes-a-and-d","text":"Initial Circuit Diagram: A | [2\u03a9] | B / \\ [4\u03a9] [6\u03a9] / \\ C \u2014\u2014[3\u03a9]\u2014\u2014 D Graph View: Nodes: A, B, C, D Edges: A\u2014B: 2\u03a9 B\u2014C: 4\u03a9 B\u2014D: 6\u03a9 C\u2014D: 3\u03a9","title":"\ud83c\udfaf Goal: Find the equivalent resistance between nodes A and D"},{"location":"1Physics/5%20Circuits/Problem_1/#step-by-step-simplification","text":"B\u2014C\u2014D forms a triangle with B\u2014D First reduce C\u2014D: no simplification yet Use Delta-to-Wye transformation if necessary Apply parallel reduction between paths to D Then, compute the total resistance from A to D Note: For complex networks, advanced transformations like Delta-Wye (\u0394-Y) may be needed.","title":"\ud83d\udd27 Step-by-Step Simplification"},{"location":"1Physics/5%20Circuits/Problem_1/#algorithm-graph-based-simplification","text":"We can automate the reduction using a loop that simplifies until no further changes are possible.","title":"\ud83e\udde0 Algorithm: Graph-Based Simplification"},{"location":"1Physics/5%20Circuits/Problem_1/#pseudocode","text":"function simplify_graph(G): repeat for each node in G: if node has degree 2: check for series configuration: replace with single resistor (R1 + R2) for each pair of nodes (u, v): if multiple resistors exist: replace with equivalent parallel resistor until no more simplifications return resistance between source and target","title":"\ud83e\uddfe Pseudocode"},{"location":"1Physics/5%20Circuits/Problem_1/#illustration-example-before-and-after","text":"Before Simplification: Graph: (weighted undirected) A \u2014(2\u03a9)\u2014 B B \u2014(4\u03a9)\u2014 C B \u2014(6\u03a9)\u2014 D C \u2014(3\u03a9)\u2014 D After Simplification: Equivalent graph (conceptual): A \u2014[R_eq]\u2014 D","title":"\ud83d\udcca Illustration: Example Before and After"},{"location":"1Physics/5%20Circuits/Problem_1/#use-cases-and-extensions","text":"\ud83d\udd0c Electrical Engineering Design Tools \ud83d\udda5\ufe0f Circuit Simulation and Visualization Software \ud83d\udcd0 Symbolic Circuit Analysis (algebraic manipulation) \ud83e\uddee Support for AC circuits and impedance (Z = R + jX) \ud83d\udd01 Integration with Kirchhoff's laws and mesh analysis \u26a1 Advanced: Delta-Wye Transformations and matrix-based reductions","title":"\ud83e\uddf0 Use Cases and Extensions"},{"location":"1Physics/5%20Circuits/Problem_1/#advanced-concepts","text":"Kirchhoff's Laws : Model using linear algebra Laplacian Matrix : Resistance as function of inverse Laplacian Delta-Wye Transformations : For reducing triangular subgraphs Interested in implementation? Ask for Python/NumPy code or an interactive visualization!","title":"\ud83e\udde9 Advanced Concepts"},{"location":"1Physics/5%20Circuits/Problem_1/#summary","text":"Graph theory offers a structured, repeatable, and automatable method to calculate equivalent resistance in electrical networks. It scales better than manual series-parallel techniques and provides the foundation for modern circuit analysis software. Use it to: Simplify large resistor networks Automate design verification Teach concepts interactively Let me know if you'd like this as a visual Markdown file with embedded diagrams or code samples!","title":"\ud83d\udccc Summary"},{"location":"1Physics/6%20Statistics/Problem_1/","text":"\ud83d\udcca Problem 1: Exploring the Central Limit Theorem (CLT) Through Simulations \ud83c\udfaf Motivation The Central Limit Theorem (CLT) is one of the foundational concepts in probability and statistics. It provides a powerful explanation for why the normal distribution appears so frequently in real-world phenomena. Definition : The CLT states that the distribution of sample means of a sufficiently large number of independent samples, drawn from any population with a finite mean and variance, will approximate a normal distribution , regardless of the shape of the original population distribution. Understanding the CLT is essential because: It justifies the use of the normal distribution in hypothesis testing and confidence intervals. It supports the validity of many statistical methods and machine learning algorithms. It offers practical guidance for data analysis, especially in sampling and estimation. This project brings the CLT to life using simulations across different population types. You\u2019ll see how sample size and distribution shape influence the convergence of the sampling distribution to normality. 1\ufe0f\u20e3 Simulating Sampling Distributions We examine the CLT by sampling from three distinct types of population distributions : \ud83d\udce6 Uniform Distribution : All values within a range are equally likely. \ud83d\udd01 Exponential Distribution : A skewed distribution with a high frequency of smaller values. \ud83c\udfaf Binomial Distribution : A discrete distribution based on the number of successes in a fixed number of trials. \ud83d\udd27 Population Generator Code import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Generate population samples of different distribution types def generate_population(distribution, size=100000): if distribution == 'uniform': return np.random.uniform(0, 1, size) elif distribution == 'exponential': return np.random.exponential(1.0, size) elif distribution == 'binomial': return np.random.binomial(n=10, p=0.5, size=size) else: raise ValueError(\"Unsupported distribution\") This function generates a large sample of 100,000 values from each of the specified distributions, which we will use as our population to sample from. 2\ufe0f\u20e3 Sampling and Visualization We draw many samples from the population and compute the mean of each sample. Then, we observe how the distribution of these sample means changes with the sample size . \ud83e\uddea Sample Means Function def sample_means(population, sample_size, num_samples): return [np.mean(np.random.choice(population, size=sample_size, replace=True)) for _ in range(num_samples)] \ud83d\udcca Plotting Function def plot_sampling_distribution(population_type, sample_sizes, num_samples=1000): population = generate_population(population_type) fig, axes = plt.subplots(1, len(sample_sizes), figsize=(5 * len(sample_sizes), 4)) for i, size in enumerate(sample_sizes): means = sample_means(population, size, num_samples) sns.histplot(means, kde=True, ax=axes[i], bins=30, color='skyblue') axes[i].set_title(f\"{population_type.capitalize()} Dist\\nSample Size = {size}\") axes[i].set_xlabel(\"Sample Mean\") axes[i].set_ylabel(\"Frequency\") plt.tight_layout() plt.show() # Example usage: plot_sampling_distribution(\"exponential\", [5, 10, 30, 50]) This produces multiple histograms, each showing how the distribution of sample means evolves as the sample size increases. 3\ufe0f\u20e3 Parameter Exploration and Observations \ud83d\udd0d Key Observations As the sample size increases , the spread of the sampling distribution decreases , and the distribution becomes more symmetric and bell-shaped . For symmetric populations like the uniform distribution, normality is achieved quickly. Skewed distributions , such as the exponential distribution, require larger sample sizes to observe the CLT in action. \ud83d\udccf Variance Shrinkage The standard deviation of the sampling distribution (also called the standard error ) decreases as the sample size increases: \\(\\text{Standard Error} = \\frac{\\sigma}{\\sqrt{n}}\\) Where: \\(\\sigma\\) = population standard deviation \\(n\\) = sample size This explains why the sampling distribution gets narrower with larger samples. 4\ufe0f\u20e3 Practical Applications \ud83d\udcbc Real-World Use Cases of CLT \ud83d\udce6 Manufacturing & Quality Control : Use the average of sampled measurements to detect defects. \ud83d\uddf3\ufe0f Political Polling : Estimate population preferences with a margin of error. \ud83d\udcc8 Finance & Economics : Predict average returns or growth rates. \ud83e\uddea Medical Research : Use sample averages to estimate treatment effects. \ud83d\udcca Business Analytics : Make decisions based on customer sample behavior. \ud83d\udcc8 Visualization Examples \ud83d\udcd8 Uniform Distribution \ud83d\udcd7 Exponential Distribution \ud83d\udcd9 Binomial Distribution Each image demonstrates how the sample mean distribution converges to a normal curve, even if the original distribution was not normal. \ud83d\udcc1 Deliverables \u2705 Modular Python functions to simulate and visualize the CLT \u2705 Histograms showing convergence behavior for various distributions and sample sizes \u2705 Insightful interpretations of statistical behavior observed through plots \u2705 Real-world context and applications of CLT \ud83d\udca1 Hints for Deeper Exploration Try adding Poisson and Gamma distributions for more variety. Use standardized sample means : subtract the mean and divide by the standard error. Explore convergence rate numerically: compute skewness and kurtosis at different sample sizes. Overlay a normal distribution curve to visually confirm convergence. Compare results to the Law of Large Numbers , which ensures the sample mean approaches the population mean. \ud83d\udcda References and Further Reading \ud83d\udcd8 Central Limit Theorem - Wikipedia \ud83d\udcf9 Visual Explanation of CLT (YouTube) \ud83d\udcd7 Khan Academy - CLT \ud83e\uddfe Summary This simulation-based project offers an intuitive and powerful way to understand the Central Limit Theorem. Through dynamic sampling and visualization, it becomes clear how even non-normal populations give rise to a normal sampling distribution\u2014paving the way for accurate statistical inference across a wide array of disciplines. Use these tools and observations to: Build intuition about the CLT Validate assumptions in your own data projects Create interactive visualizations for teaching and reporting Let me know if you\u2019d like to add interactive widgets or animations!","title":"\ud83d\udcca Problem 1: Exploring the Central Limit Theorem (CLT) Through Simulations"},{"location":"1Physics/6%20Statistics/Problem_1/#problem-1-exploring-the-central-limit-theorem-clt-through-simulations","text":"","title":"\ud83d\udcca Problem 1: Exploring the Central Limit Theorem (CLT) Through Simulations"},{"location":"1Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is one of the foundational concepts in probability and statistics. It provides a powerful explanation for why the normal distribution appears so frequently in real-world phenomena. Definition : The CLT states that the distribution of sample means of a sufficiently large number of independent samples, drawn from any population with a finite mean and variance, will approximate a normal distribution , regardless of the shape of the original population distribution. Understanding the CLT is essential because: It justifies the use of the normal distribution in hypothesis testing and confidence intervals. It supports the validity of many statistical methods and machine learning algorithms. It offers practical guidance for data analysis, especially in sampling and estimation. This project brings the CLT to life using simulations across different population types. You\u2019ll see how sample size and distribution shape influence the convergence of the sampling distribution to normality.","title":"\ud83c\udfaf Motivation"},{"location":"1Physics/6%20Statistics/Problem_1/#1-simulating-sampling-distributions","text":"We examine the CLT by sampling from three distinct types of population distributions : \ud83d\udce6 Uniform Distribution : All values within a range are equally likely. \ud83d\udd01 Exponential Distribution : A skewed distribution with a high frequency of smaller values. \ud83c\udfaf Binomial Distribution : A discrete distribution based on the number of successes in a fixed number of trials.","title":"1\ufe0f\u20e3 Simulating Sampling Distributions"},{"location":"1Physics/6%20Statistics/Problem_1/#population-generator-code","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Generate population samples of different distribution types def generate_population(distribution, size=100000): if distribution == 'uniform': return np.random.uniform(0, 1, size) elif distribution == 'exponential': return np.random.exponential(1.0, size) elif distribution == 'binomial': return np.random.binomial(n=10, p=0.5, size=size) else: raise ValueError(\"Unsupported distribution\") This function generates a large sample of 100,000 values from each of the specified distributions, which we will use as our population to sample from.","title":"\ud83d\udd27 Population Generator Code"},{"location":"1Physics/6%20Statistics/Problem_1/#2-sampling-and-visualization","text":"We draw many samples from the population and compute the mean of each sample. Then, we observe how the distribution of these sample means changes with the sample size .","title":"2\ufe0f\u20e3 Sampling and Visualization"},{"location":"1Physics/6%20Statistics/Problem_1/#sample-means-function","text":"def sample_means(population, sample_size, num_samples): return [np.mean(np.random.choice(population, size=sample_size, replace=True)) for _ in range(num_samples)]","title":"\ud83e\uddea Sample Means Function"},{"location":"1Physics/6%20Statistics/Problem_1/#plotting-function","text":"def plot_sampling_distribution(population_type, sample_sizes, num_samples=1000): population = generate_population(population_type) fig, axes = plt.subplots(1, len(sample_sizes), figsize=(5 * len(sample_sizes), 4)) for i, size in enumerate(sample_sizes): means = sample_means(population, size, num_samples) sns.histplot(means, kde=True, ax=axes[i], bins=30, color='skyblue') axes[i].set_title(f\"{population_type.capitalize()} Dist\\nSample Size = {size}\") axes[i].set_xlabel(\"Sample Mean\") axes[i].set_ylabel(\"Frequency\") plt.tight_layout() plt.show() # Example usage: plot_sampling_distribution(\"exponential\", [5, 10, 30, 50]) This produces multiple histograms, each showing how the distribution of sample means evolves as the sample size increases.","title":"\ud83d\udcca Plotting Function"},{"location":"1Physics/6%20Statistics/Problem_1/#3-parameter-exploration-and-observations","text":"","title":"3\ufe0f\u20e3 Parameter Exploration and Observations"},{"location":"1Physics/6%20Statistics/Problem_1/#key-observations","text":"As the sample size increases , the spread of the sampling distribution decreases , and the distribution becomes more symmetric and bell-shaped . For symmetric populations like the uniform distribution, normality is achieved quickly. Skewed distributions , such as the exponential distribution, require larger sample sizes to observe the CLT in action.","title":"\ud83d\udd0d Key Observations"},{"location":"1Physics/6%20Statistics/Problem_1/#variance-shrinkage","text":"The standard deviation of the sampling distribution (also called the standard error ) decreases as the sample size increases: \\(\\text{Standard Error} = \\frac{\\sigma}{\\sqrt{n}}\\) Where: \\(\\sigma\\) = population standard deviation \\(n\\) = sample size This explains why the sampling distribution gets narrower with larger samples.","title":"\ud83d\udccf Variance Shrinkage"},{"location":"1Physics/6%20Statistics/Problem_1/#4-practical-applications","text":"","title":"4\ufe0f\u20e3 Practical Applications"},{"location":"1Physics/6%20Statistics/Problem_1/#real-world-use-cases-of-clt","text":"\ud83d\udce6 Manufacturing & Quality Control : Use the average of sampled measurements to detect defects. \ud83d\uddf3\ufe0f Political Polling : Estimate population preferences with a margin of error. \ud83d\udcc8 Finance & Economics : Predict average returns or growth rates. \ud83e\uddea Medical Research : Use sample averages to estimate treatment effects. \ud83d\udcca Business Analytics : Make decisions based on customer sample behavior.","title":"\ud83d\udcbc Real-World Use Cases of CLT"},{"location":"1Physics/6%20Statistics/Problem_1/#visualization-examples","text":"","title":"\ud83d\udcc8 Visualization Examples"},{"location":"1Physics/6%20Statistics/Problem_1/#uniform-distribution","text":"","title":"\ud83d\udcd8 Uniform Distribution"},{"location":"1Physics/6%20Statistics/Problem_1/#exponential-distribution","text":"","title":"\ud83d\udcd7 Exponential Distribution"},{"location":"1Physics/6%20Statistics/Problem_1/#binomial-distribution","text":"Each image demonstrates how the sample mean distribution converges to a normal curve, even if the original distribution was not normal.","title":"\ud83d\udcd9 Binomial Distribution"},{"location":"1Physics/6%20Statistics/Problem_1/#deliverables","text":"\u2705 Modular Python functions to simulate and visualize the CLT \u2705 Histograms showing convergence behavior for various distributions and sample sizes \u2705 Insightful interpretations of statistical behavior observed through plots \u2705 Real-world context and applications of CLT","title":"\ud83d\udcc1 Deliverables"},{"location":"1Physics/6%20Statistics/Problem_1/#hints-for-deeper-exploration","text":"Try adding Poisson and Gamma distributions for more variety. Use standardized sample means : subtract the mean and divide by the standard error. Explore convergence rate numerically: compute skewness and kurtosis at different sample sizes. Overlay a normal distribution curve to visually confirm convergence. Compare results to the Law of Large Numbers , which ensures the sample mean approaches the population mean.","title":"\ud83d\udca1 Hints for Deeper Exploration"},{"location":"1Physics/6%20Statistics/Problem_1/#references-and-further-reading","text":"\ud83d\udcd8 Central Limit Theorem - Wikipedia \ud83d\udcf9 Visual Explanation of CLT (YouTube) \ud83d\udcd7 Khan Academy - CLT","title":"\ud83d\udcda References and Further Reading"},{"location":"1Physics/6%20Statistics/Problem_1/#summary","text":"This simulation-based project offers an intuitive and powerful way to understand the Central Limit Theorem. Through dynamic sampling and visualization, it becomes clear how even non-normal populations give rise to a normal sampling distribution\u2014paving the way for accurate statistical inference across a wide array of disciplines. Use these tools and observations to: Build intuition about the CLT Validate assumptions in your own data projects Create interactive visualizations for teaching and reporting Let me know if you\u2019d like to add interactive widgets or animations!","title":"\ud83e\uddfe Summary"},{"location":"1Physics/6%20Statistics/Problem_2/","text":"Problem 2: Estimating \u03c0 Using Monte Carlo Methods \ud83c\udfaf Introduction Monte Carlo methods are powerful computational techniques that use random sampling to solve numerical problems. A classic application of this method is estimating the mathematical constant \u03c0 (pi) . This problem explores and compares two distinct Monte Carlo-based approaches: \ud83c\udfaf Circle Method : Estimating \u03c0 using random points inside a square enclosing a circle \ud83e\udea1 Buffon's Needle Method : Estimating \u03c0 based on the probability of a needle intersecting lines when dropped randomly \ud83d\udccc Part 1: Estimating \u03c0 Using a Circle 1\ufe0f\u20e3 Theoretical Foundation Consider a unit circle (radius = 1) perfectly inscribed in a square of side 2. The ratio of their areas is: Area of the Circle = \\(\\pi r^2 = \\pi\\) Area of the Square = \\((2r)^2 = 4\\) \\(\\text{Ratio} = \\frac{\\text{Area of Circle}}{\\text{Area of Square}} = \\frac{\\pi}{4}\\) If we generate random points within the square and count how many fall inside the circle, we can approximate \u03c0: \\(\\pi \\approx 4 \\times \\frac{\\text{Points in Circle}}{\\text{Total Points}}\\) 2\ufe0f\u20e3 Simulation Code import numpy as np import matplotlib.pyplot as plt def monte_carlo_pi(num_points): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / num_points return x, y, inside, pi_estimate # Example usage x, y, inside, pi_val = monte_carlo_pi(10000) print(f\"Estimated \u03c0 = {pi_val}\") 3\ufe0f\u20e3 Visualization def plot_circle_simulation(x, y, inside): plt.figure(figsize=(8, 8)) plt.scatter(x[inside], y[inside], color='green', s=1, alpha=0.5, label=\"Inside Circle\") plt.scatter(x[~inside], y[~inside], color='red', s=1, alpha=0.5, label=\"Outside Circle\") circle = plt.Circle((0,0), 1, color='blue', fill=False, linewidth=2) plt.gca().add_artist(circle) plt.gca().set_aspect('equal') plt.title(f\"Monte Carlo Estimation of \u03c0 (n={len(x)})\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.grid(True) plt.xlim(-1.1, 1.1) plt.ylim(-1.1, 1.1) plt.show() plot_circle_simulation(x, y, inside) \ud83d\udd0d Visual Example 4\ufe0f\u20e3 Convergence Analysis Points \u03c0 Estimate Error (%) 100 \\~3.16 \\~0.6% 1,000 \\~3.14 \\~0.05% 10,000 \\~3.1416 \\~0.001% 100,000 \\~3.14159 \\~0.0001% Observation : Error decreases with \\(\\frac{1}{\\sqrt{n}}\\) , a key feature of Monte Carlo convergence. \ud83d\udccc Part 2: Estimating \u03c0 Using Buffon's Needle 1\ufe0f\u20e3 Theoretical Foundation Buffon's Needle is a geometric probability method from the 18th century. If a needle of length \\(L\\) is dropped on a surface with parallel lines spaced \\(D\\) units apart (where \\(L \\leq D\\) ), the probability of the needle crossing a line is: \\(P = \\frac{2L}{\\pi D} \\Rightarrow \\pi \\approx \\frac{2L \\cdot N}{D \\cdot N_c}\\) Where: \\(N\\) is the number of needle drops \\(N_c\\) is the number of crossings 2\ufe0f\u20e3 Simulation Code def buffon_needle_simulation(num_needles, L=1.0, D=2.0): x_centers = np.random.uniform(0, D/2, num_needles) angles = np.random.uniform(0, np.pi/2, num_needles) crosses = x_centers <= (L/2) * np.sin(angles) pi_estimate = (2 * L * num_needles) / (D * np.sum(crosses)) return x_centers, angles, crosses, pi_estimate x_c, a_c, cross, pi_b = buffon_needle_simulation(10000) print(f\"Estimated \u03c0 (Buffon's) = {pi_b}\") 3\ufe0f\u20e3 Visualization def plot_buffon_simulation(x_centers, angles, crosses, L=1.0, D=2.0, max_needles=200): fig, ax = plt.subplots(figsize=(10, 6)) for i, crossed in enumerate(crosses[:max_needles]): x = x_centers[i] theta = angles[i] x1 = x - (L/2) * np.cos(theta) x2 = x + (L/2) * np.cos(theta) y = i * 0.1 ax.plot([x1, x2], [y, y], 'g-' if crossed else 'r-', lw=1.5) for i in range(0, int(0.1 * max_needles) + 2): ax.axhline(i * D, color='gray', lw=1, linestyle='--') ax.set_title(f\"Buffon's Needle Simulation (n={len(crosses)})\") ax.set_xlabel(\"Position\") ax.set_xlim(0, D) ax.set_ylim(0, max(20, 0.1 * max_needles)) ax.set_yticks([]) plt.show() plot_buffon_simulation(x_c, a_c, cross) \ud83c\udfaf Visual Example 4\ufe0f\u20e3 Convergence Analysis Needles \u03c0 Estimate Error (%) 100 \\~3.10 \\~1.3% 1,000 \\~3.15 \\~0.2% 10,000 \\~3.141 \\~0.02% \ud83c\udd9a Method Comparison Method Pros Cons Best Use Case Circle Method Simple & fast convergence Requires square root ops Educational visualization Buffon's Needle Historical & probabilistic Slower convergence Teaching geometric prob. \ud83d\udcc1 Deliverables \u2705 Python code for both estimation methods \u2705 Visualizations for each simulation \u2705 Analytical comparison of convergence rates \u2705 Method comparison table \ud83d\udcda References & Resources Monte Carlo Method - Wikipedia Buffon's Needle - Wolfram MathWorld Visual Pi Estimation Animation This expanded section adds mathematical derivations, simulation insights, visualization examples, and comparison tools to deeply explore Monte Carlo techniques for estimating \u03c0.","title":"Problem 2: Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1Physics/6%20Statistics/Problem_2/#problem-2-estimating-using-monte-carlo-methods","text":"","title":"Problem 2: Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1Physics/6%20Statistics/Problem_2/#introduction","text":"Monte Carlo methods are powerful computational techniques that use random sampling to solve numerical problems. A classic application of this method is estimating the mathematical constant \u03c0 (pi) . This problem explores and compares two distinct Monte Carlo-based approaches: \ud83c\udfaf Circle Method : Estimating \u03c0 using random points inside a square enclosing a circle \ud83e\udea1 Buffon's Needle Method : Estimating \u03c0 based on the probability of a needle intersecting lines when dropped randomly","title":"\ud83c\udfaf Introduction"},{"location":"1Physics/6%20Statistics/Problem_2/#part-1-estimating-using-a-circle","text":"","title":"\ud83d\udccc Part 1: Estimating \u03c0 Using a Circle"},{"location":"1Physics/6%20Statistics/Problem_2/#1-theoretical-foundation","text":"Consider a unit circle (radius = 1) perfectly inscribed in a square of side 2. The ratio of their areas is: Area of the Circle = \\(\\pi r^2 = \\pi\\) Area of the Square = \\((2r)^2 = 4\\) \\(\\text{Ratio} = \\frac{\\text{Area of Circle}}{\\text{Area of Square}} = \\frac{\\pi}{4}\\) If we generate random points within the square and count how many fall inside the circle, we can approximate \u03c0: \\(\\pi \\approx 4 \\times \\frac{\\text{Points in Circle}}{\\text{Total Points}}\\)","title":"1\ufe0f\u20e3 Theoretical Foundation"},{"location":"1Physics/6%20Statistics/Problem_2/#2-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt def monte_carlo_pi(num_points): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / num_points return x, y, inside, pi_estimate # Example usage x, y, inside, pi_val = monte_carlo_pi(10000) print(f\"Estimated \u03c0 = {pi_val}\")","title":"2\ufe0f\u20e3 Simulation Code"},{"location":"1Physics/6%20Statistics/Problem_2/#3-visualization","text":"def plot_circle_simulation(x, y, inside): plt.figure(figsize=(8, 8)) plt.scatter(x[inside], y[inside], color='green', s=1, alpha=0.5, label=\"Inside Circle\") plt.scatter(x[~inside], y[~inside], color='red', s=1, alpha=0.5, label=\"Outside Circle\") circle = plt.Circle((0,0), 1, color='blue', fill=False, linewidth=2) plt.gca().add_artist(circle) plt.gca().set_aspect('equal') plt.title(f\"Monte Carlo Estimation of \u03c0 (n={len(x)})\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.grid(True) plt.xlim(-1.1, 1.1) plt.ylim(-1.1, 1.1) plt.show() plot_circle_simulation(x, y, inside)","title":"3\ufe0f\u20e3 Visualization"},{"location":"1Physics/6%20Statistics/Problem_2/#visual-example","text":"","title":"\ud83d\udd0d Visual Example"},{"location":"1Physics/6%20Statistics/Problem_2/#4-convergence-analysis","text":"Points \u03c0 Estimate Error (%) 100 \\~3.16 \\~0.6% 1,000 \\~3.14 \\~0.05% 10,000 \\~3.1416 \\~0.001% 100,000 \\~3.14159 \\~0.0001% Observation : Error decreases with \\(\\frac{1}{\\sqrt{n}}\\) , a key feature of Monte Carlo convergence.","title":"4\ufe0f\u20e3 Convergence Analysis"},{"location":"1Physics/6%20Statistics/Problem_2/#part-2-estimating-using-buffons-needle","text":"","title":"\ud83d\udccc Part 2: Estimating \u03c0 Using Buffon's Needle"},{"location":"1Physics/6%20Statistics/Problem_2/#1-theoretical-foundation_1","text":"Buffon's Needle is a geometric probability method from the 18th century. If a needle of length \\(L\\) is dropped on a surface with parallel lines spaced \\(D\\) units apart (where \\(L \\leq D\\) ), the probability of the needle crossing a line is: \\(P = \\frac{2L}{\\pi D} \\Rightarrow \\pi \\approx \\frac{2L \\cdot N}{D \\cdot N_c}\\) Where: \\(N\\) is the number of needle drops \\(N_c\\) is the number of crossings","title":"1\ufe0f\u20e3 Theoretical Foundation"},{"location":"1Physics/6%20Statistics/Problem_2/#2-simulation-code_1","text":"def buffon_needle_simulation(num_needles, L=1.0, D=2.0): x_centers = np.random.uniform(0, D/2, num_needles) angles = np.random.uniform(0, np.pi/2, num_needles) crosses = x_centers <= (L/2) * np.sin(angles) pi_estimate = (2 * L * num_needles) / (D * np.sum(crosses)) return x_centers, angles, crosses, pi_estimate x_c, a_c, cross, pi_b = buffon_needle_simulation(10000) print(f\"Estimated \u03c0 (Buffon's) = {pi_b}\")","title":"2\ufe0f\u20e3 Simulation Code"},{"location":"1Physics/6%20Statistics/Problem_2/#3-visualization_1","text":"def plot_buffon_simulation(x_centers, angles, crosses, L=1.0, D=2.0, max_needles=200): fig, ax = plt.subplots(figsize=(10, 6)) for i, crossed in enumerate(crosses[:max_needles]): x = x_centers[i] theta = angles[i] x1 = x - (L/2) * np.cos(theta) x2 = x + (L/2) * np.cos(theta) y = i * 0.1 ax.plot([x1, x2], [y, y], 'g-' if crossed else 'r-', lw=1.5) for i in range(0, int(0.1 * max_needles) + 2): ax.axhline(i * D, color='gray', lw=1, linestyle='--') ax.set_title(f\"Buffon's Needle Simulation (n={len(crosses)})\") ax.set_xlabel(\"Position\") ax.set_xlim(0, D) ax.set_ylim(0, max(20, 0.1 * max_needles)) ax.set_yticks([]) plt.show() plot_buffon_simulation(x_c, a_c, cross)","title":"3\ufe0f\u20e3 Visualization"},{"location":"1Physics/6%20Statistics/Problem_2/#visual-example_1","text":"","title":"\ud83c\udfaf Visual Example"},{"location":"1Physics/6%20Statistics/Problem_2/#4-convergence-analysis_1","text":"Needles \u03c0 Estimate Error (%) 100 \\~3.10 \\~1.3% 1,000 \\~3.15 \\~0.2% 10,000 \\~3.141 \\~0.02%","title":"4\ufe0f\u20e3 Convergence Analysis"},{"location":"1Physics/6%20Statistics/Problem_2/#method-comparison","text":"Method Pros Cons Best Use Case Circle Method Simple & fast convergence Requires square root ops Educational visualization Buffon's Needle Historical & probabilistic Slower convergence Teaching geometric prob.","title":"\ud83c\udd9a Method Comparison"},{"location":"1Physics/6%20Statistics/Problem_2/#deliverables","text":"\u2705 Python code for both estimation methods \u2705 Visualizations for each simulation \u2705 Analytical comparison of convergence rates \u2705 Method comparison table","title":"\ud83d\udcc1 Deliverables"},{"location":"1Physics/6%20Statistics/Problem_2/#references-resources","text":"Monte Carlo Method - Wikipedia Buffon's Needle - Wolfram MathWorld Visual Pi Estimation Animation This expanded section adds mathematical derivations, simulation insights, visualization examples, and comparison tools to deeply explore Monte Carlo techniques for estimating \u03c0.","title":"\ud83d\udcda References &amp; Resources"},{"location":"1Physics/7%20Measurements/Problem_1/","text":"Problem 1 \ud83e\uddea Measuring Earth's Gravitational Acceleration with a Pendulum \ud83c\udfaf Motivation The acceleration due to gravity \\(g\\) is a foundational physical constant central to fields such as mechanics, civil engineering, aerospace design, and physics education. One of the most accessible and elegant ways to estimate \\(g\\) is using the simple pendulum \u2014 a system studied since the era of Galileo. This experiment demonstrates how basic tools and data analysis can be used to produce an accurate estimate of \\(g\\) , while introducing essential scientific skills: measurement precision, data handling, and uncertainty quantification. \ud83d\udd27 Materials Required Item Purpose String (1\u20131.5 meters) Acts as the pendulum arm Small mass/weight Creates the pendulum bob Stopwatch/smartphone Measures time intervals Ruler or measuring tape Measures the length \\(L\\) Clamp/stand (optional) Provides stable support for suspension \ud83d\udd0d Note: Ensure that the environment is free of strong air currents and the mass swings freely without obstruction. \u2699\ufe0f Experimental Setup Assembly : Tie one end of the string to a fixed support and attach the mass to the other end. Length Measurement : Measure the length \\(L\\) from the suspension point to the mass center. Use a ruler with millimeter resolution if possible. Displacement : Gently pull the pendulum back by less than 15\u00b0 from the vertical to maintain the small-angle approximation. Measurement Uncertainty : If using a ruler with 1 cm divisions, uncertainty in \\(L\\) is \\(u_L = 0.005\\) m. \ud83d\udcca Data Collection Conduct 10 trials , each measuring the time for 10 full oscillations . Record your observations in a table: Trial Time for 10 Oscillations (s) 1 20.31 2 20.29 3 20.33 4 20.28 5 20.32 6 20.35 7 20.30 8 20.34 9 20.29 10 20.31 \ud83d\udd0e Calculated Averages and Uncertainties \ud83e\uddee Period Calculation Mean time for 10 oscillations: \\(\\overline{t}_{10} = 20.312\\) s Period \\(T = \\frac{\\overline{t}_{10}}{10} = 2.0312\\) s Standard deviation: \\(\\sigma = 0.020\\) s Uncertainty in mean: \\(u_T = \\frac{\\sigma}{\\sqrt{10} \\cdot 10} = 0.00063\\) s \ud83e\udde0 Theoretical Basis and Calculations 1\ufe0f\u20e3 Formula for Gravity \\[ g = \\frac{4\\pi^2 L}{T^2} \\] Given: \\(L = 1.000 \\pm 0.005\\) m \\(T = 2.0312 \\pm 0.00063\\) s Substitute: \\[ g = \\frac{4\\pi^2 \\cdot 1.000}{(2.0312)^2} \\approx 9.55 \\ \\text{m/s}^2 \\] 2\ufe0f\u20e3 Propagating Uncertainty \\[ \\frac{u_g}{g} = \\sqrt{\\left(\\frac{u_L}{L}\\right)^2 + \\left(2\\cdot\\frac{u_T}{T}\\right)^2} \\] \\[ \\frac{u_g}{g} = \\sqrt{\\left(\\frac{0.005}{1.000}\\right)^2 + \\left(2\\cdot\\frac{0.00063}{2.0312}\\right)^2} \\approx 0.00515 \\] \\[ u_g = 9.55 \\cdot 0.00515 \\approx 0.049 \\ \\text{m/s}^2 \\] \u2705 Final Result \\[ \\boxed{g = 9.55 \\pm 0.05 \\ \\text{m/s}^2} \\] \ud83d\udccc Results Interpretation \ud83d\udcc9 Comparison to Standard Value Standard gravitational acceleration: \\(g = 9.81 \\ \\text{m/s}^2\\) Absolute error: \\(|9.55 - 9.81| = 0.26 \\ \\text{m/s}^2\\) Relative error: \\(\\frac{0.26}{9.81} \\approx 2.65\\%\\) \u26a0\ufe0f Sources of Uncertainty Source Impact Length measurement Inexact center-of-mass estimation and parallax error Timing error Manual stopwatch handling introduces latency Air resistance Can slightly dampen the motion and alter period Amplitude assumption Over 15\u00b0 leads to nonlinear behavior \ud83e\udde0 Improving reliability: Use light gates or motion sensors for precise time tracking. \ud83d\udcc8 Visualization Examples \ud83d\udccd Time vs. Trial Plot import matplotlib.pyplot as plt trials = list(range(1, 11)) times = [20.31, 20.29, 20.33, 20.28, 20.32, 20.35, 20.30, 20.34, 20.29, 20.31] plt.figure(figsize=(8, 4)) plt.plot(trials, times, marker='o', linestyle='-', color='navy') plt.axhline(sum(times)/len(times), color='red', linestyle='--', label='Mean Time') plt.title(\"Pendulum Oscillation Time per Trial\") plt.xlabel(\"Trial\") plt.ylabel(\"Time for 10 Oscillations (s)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() \ud83e\uddf0 Optional Extensions Try different lengths \\(L\\) and observe how \\(T\\) changes. Plot \\(T^2\\) vs \\(L\\) ; the slope will be \\(\\frac{4\\pi^2}{g}\\) . Fit a linear regression to determine \\(g\\) experimentally. \ud83d\udcc1 Deliverables Summary \u2705 Table of oscillation times \u2705 Calculated mean, standard deviation, and period \u2705 Final gravity value with uncertainty \u2705 Discussion of errors and result interpretation \u2705 Python plots and optional data visualization \u2705 Recommendations for improving measurement reliability \ud83d\udcda References & Resources Simple Pendulum - Wikipedia Uncertainty Propagation - Wikipedia Pendulum Calculator YouTube - How to Measure g with a Pendulum","title":"Problem 1"},{"location":"1Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"\ud83e\uddea Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration due to gravity \\(g\\) is a foundational physical constant central to fields such as mechanics, civil engineering, aerospace design, and physics education. One of the most accessible and elegant ways to estimate \\(g\\) is using the simple pendulum \u2014 a system studied since the era of Galileo. This experiment demonstrates how basic tools and data analysis can be used to produce an accurate estimate of \\(g\\) , while introducing essential scientific skills: measurement precision, data handling, and uncertainty quantification.","title":"\ud83c\udfaf Motivation"},{"location":"1Physics/7%20Measurements/Problem_1/#materials-required","text":"Item Purpose String (1\u20131.5 meters) Acts as the pendulum arm Small mass/weight Creates the pendulum bob Stopwatch/smartphone Measures time intervals Ruler or measuring tape Measures the length \\(L\\) Clamp/stand (optional) Provides stable support for suspension \ud83d\udd0d Note: Ensure that the environment is free of strong air currents and the mass swings freely without obstruction.","title":"\ud83d\udd27 Materials Required"},{"location":"1Physics/7%20Measurements/Problem_1/#experimental-setup","text":"Assembly : Tie one end of the string to a fixed support and attach the mass to the other end. Length Measurement : Measure the length \\(L\\) from the suspension point to the mass center. Use a ruler with millimeter resolution if possible. Displacement : Gently pull the pendulum back by less than 15\u00b0 from the vertical to maintain the small-angle approximation. Measurement Uncertainty : If using a ruler with 1 cm divisions, uncertainty in \\(L\\) is \\(u_L = 0.005\\) m.","title":"\u2699\ufe0f Experimental Setup"},{"location":"1Physics/7%20Measurements/Problem_1/#data-collection","text":"Conduct 10 trials , each measuring the time for 10 full oscillations . Record your observations in a table: Trial Time for 10 Oscillations (s) 1 20.31 2 20.29 3 20.33 4 20.28 5 20.32 6 20.35 7 20.30 8 20.34 9 20.29 10 20.31","title":"\ud83d\udcca Data Collection"},{"location":"1Physics/7%20Measurements/Problem_1/#calculated-averages-and-uncertainties","text":"","title":"\ud83d\udd0e Calculated Averages and Uncertainties"},{"location":"1Physics/7%20Measurements/Problem_1/#period-calculation","text":"Mean time for 10 oscillations: \\(\\overline{t}_{10} = 20.312\\) s Period \\(T = \\frac{\\overline{t}_{10}}{10} = 2.0312\\) s Standard deviation: \\(\\sigma = 0.020\\) s Uncertainty in mean: \\(u_T = \\frac{\\sigma}{\\sqrt{10} \\cdot 10} = 0.00063\\) s","title":"\ud83e\uddee Period Calculation"},{"location":"1Physics/7%20Measurements/Problem_1/#theoretical-basis-and-calculations","text":"","title":"\ud83e\udde0 Theoretical Basis and Calculations"},{"location":"1Physics/7%20Measurements/Problem_1/#1-formula-for-gravity","text":"\\[ g = \\frac{4\\pi^2 L}{T^2} \\] Given: \\(L = 1.000 \\pm 0.005\\) m \\(T = 2.0312 \\pm 0.00063\\) s Substitute: \\[ g = \\frac{4\\pi^2 \\cdot 1.000}{(2.0312)^2} \\approx 9.55 \\ \\text{m/s}^2 \\]","title":"1\ufe0f\u20e3 Formula for Gravity"},{"location":"1Physics/7%20Measurements/Problem_1/#2-propagating-uncertainty","text":"\\[ \\frac{u_g}{g} = \\sqrt{\\left(\\frac{u_L}{L}\\right)^2 + \\left(2\\cdot\\frac{u_T}{T}\\right)^2} \\] \\[ \\frac{u_g}{g} = \\sqrt{\\left(\\frac{0.005}{1.000}\\right)^2 + \\left(2\\cdot\\frac{0.00063}{2.0312}\\right)^2} \\approx 0.00515 \\] \\[ u_g = 9.55 \\cdot 0.00515 \\approx 0.049 \\ \\text{m/s}^2 \\]","title":"2\ufe0f\u20e3 Propagating Uncertainty"},{"location":"1Physics/7%20Measurements/Problem_1/#final-result","text":"\\[ \\boxed{g = 9.55 \\pm 0.05 \\ \\text{m/s}^2} \\]","title":"\u2705 Final Result"},{"location":"1Physics/7%20Measurements/Problem_1/#results-interpretation","text":"","title":"\ud83d\udccc Results Interpretation"},{"location":"1Physics/7%20Measurements/Problem_1/#comparison-to-standard-value","text":"Standard gravitational acceleration: \\(g = 9.81 \\ \\text{m/s}^2\\) Absolute error: \\(|9.55 - 9.81| = 0.26 \\ \\text{m/s}^2\\) Relative error: \\(\\frac{0.26}{9.81} \\approx 2.65\\%\\)","title":"\ud83d\udcc9 Comparison to Standard Value"},{"location":"1Physics/7%20Measurements/Problem_1/#sources-of-uncertainty","text":"Source Impact Length measurement Inexact center-of-mass estimation and parallax error Timing error Manual stopwatch handling introduces latency Air resistance Can slightly dampen the motion and alter period Amplitude assumption Over 15\u00b0 leads to nonlinear behavior \ud83e\udde0 Improving reliability: Use light gates or motion sensors for precise time tracking.","title":"\u26a0\ufe0f Sources of Uncertainty"},{"location":"1Physics/7%20Measurements/Problem_1/#visualization-examples","text":"","title":"\ud83d\udcc8 Visualization Examples"},{"location":"1Physics/7%20Measurements/Problem_1/#time-vs-trial-plot","text":"import matplotlib.pyplot as plt trials = list(range(1, 11)) times = [20.31, 20.29, 20.33, 20.28, 20.32, 20.35, 20.30, 20.34, 20.29, 20.31] plt.figure(figsize=(8, 4)) plt.plot(trials, times, marker='o', linestyle='-', color='navy') plt.axhline(sum(times)/len(times), color='red', linestyle='--', label='Mean Time') plt.title(\"Pendulum Oscillation Time per Trial\") plt.xlabel(\"Trial\") plt.ylabel(\"Time for 10 Oscillations (s)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"\ud83d\udccd Time vs. Trial Plot"},{"location":"1Physics/7%20Measurements/Problem_1/#optional-extensions","text":"Try different lengths \\(L\\) and observe how \\(T\\) changes. Plot \\(T^2\\) vs \\(L\\) ; the slope will be \\(\\frac{4\\pi^2}{g}\\) . Fit a linear regression to determine \\(g\\) experimentally.","title":"\ud83e\uddf0 Optional Extensions"},{"location":"1Physics/7%20Measurements/Problem_1/#deliverables-summary","text":"\u2705 Table of oscillation times \u2705 Calculated mean, standard deviation, and period \u2705 Final gravity value with uncertainty \u2705 Discussion of errors and result interpretation \u2705 Python plots and optional data visualization \u2705 Recommendations for improving measurement reliability","title":"\ud83d\udcc1 Deliverables Summary"},{"location":"1Physics/7%20Measurements/Problem_1/#references-resources","text":"Simple Pendulum - Wikipedia Uncertainty Propagation - Wikipedia Pendulum Calculator YouTube - How to Measure g with a Pendulum","title":"\ud83d\udcda References &amp; Resources"},{"location":"2Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3Discret_Mathematics/1%20Set%20Theory%20and/_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3Discret_Mathematics/1%20Set%20Theory%20and/_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3Discret_Mathematics/1%20Set%20Theory%20and/_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3Discret_Mathematics/1%20Set%20Theory%20and/_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3Discret_Mathematics/1%20Set%20Theory%20and/_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3Discret_Mathematics/1%20Set%20Theory%20and/_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3Discret_Mathematics/2%20Number%20Theory%20and/_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3Discret_Mathematics/2%20Number%20Theory%20and/_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3Discret_Mathematics/2%20Number%20Theory%20and/_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3Discret_Mathematics/2%20Number%20Theory%20and/_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3Discret_Mathematics/3%20Recurrence%20and/_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3Discret_Mathematics/3%20Recurrence%20and/_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3Discret_Mathematics/3%20Recurrence%20and/_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3Discret_Mathematics/3%20Recurrence%20and/_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3Discret_Mathematics/3%20Recurrence%20and/_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3Discret_Mathematics/3%20Recurrence%20and/_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3Discret_Mathematics/4%20Graph%20Theory%20and/_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3Discret_Mathematics/4%20Graph%20Theory%20and/_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}